{"meta":{"title":"Xin's Blog","subtitle":"Xin's Blog","description":"专注于linux运维","author":"xin","url":"http://xinilhy.github.io"},"pages":[{"title":"","date":"2017-02-24T09:37:05.000Z","updated":"2017-02-24T09:37:05.000Z","comments":true,"path":"tags/index.html","permalink":"http://xinilhy.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-24T09:37:05.000Z","updated":"2017-02-24T09:37:05.000Z","comments":true,"path":"archives/index.html","permalink":"http://xinilhy.github.io/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"shelll编程之select循环与菜单","slug":"shell编程之select循环与菜单","date":"2018-10-07T13:03:54.000Z","updated":"2018-10-15T06:08:08.230Z","comments":true,"path":"2018/10/07/shell编程之select循环与菜单/","link":"","permalink":"http://xinilhy.github.io/2018/10/07/shell编程之select循环与菜单/","excerpt":"select循环与菜单 语法 1234select variable in listdo循环体命令done","text":"select循环与菜单 语法 1234select variable in listdo循环体命令done select 循环主要用于创建菜单，按数字顺序排列的菜单项将显示在标准错误上，并显示 PS3 提示符，等待用户输入 用户输入菜单列表中的某个数字，执行相应的命令 用户输入被保存在内置变量 REPLY 中 select 是个无限循环，因此要记住用 break 命令退出循环，或用 exit 命令终止脚本。也可以按 ctrl+c 退出循环 select 经常和 case 联合使用 与 for 循环类似，可以省略 in list，此时使用位置参量 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@centos7 scripts ]#cat select.sh #!/bin/bashPS3=&quot;please choose a digit: &quot; ## PS3专门用来提供输入select MENU in jiaozi lamian mifan daoxiaomian quit;do ## in后面的参数默认按照序号1 2 3 4等一一对应； case $MENU in jiaozi) echo &quot;Your choose is $REPLY&quot; ## 变量REPLY专门用于存储用户输入的结果 echo &quot;$MENU price is 20&quot; ;; lamian) echo &quot;Your choose is $REPLY&quot; echo &quot;$MENU price is 15&quot; ;; mifan) echo &quot;Your choose is $REPLY&quot; echo &quot;$MENU price is 18&quot; ;; daoxiaomian) echo &quot;Your choose is $REPLY&quot; echo &quot;$MENU price is 12&quot; ;; quit) echo &quot;Your choose is $REPLY&quot; break ;; *) echo &quot;Your choose is $REPLY&quot; echo &quot;choose again&quot; ;; esacdone[root@centos7 scripts ]#./select.sh 1) jiaozi2) lamian3) mifan4) daoxiaomian5) quitplease choose a digit: 1Your choose is 1jiaozi price is 20please choose a digit: 2Your choose is 2lamian price is 15please choose a digit: 5Your choose is 5","categories":[{"name":"shell","slug":"shell","permalink":"http://xinilhy.github.io/categories/shell/"}],"tags":[{"name":"shell编程","slug":"shell编程","permalink":"http://xinilhy.github.io/tags/shell编程/"}]},{"title":"shell编程之while特殊用法","slug":"shell编程之while特殊用法","date":"2018-10-06T13:03:54.000Z","updated":"2018-10-15T06:10:23.492Z","comments":true,"path":"2018/10/06/shell编程之while特殊用法/","link":"","permalink":"http://xinilhy.github.io/2018/10/06/shell编程之while特殊用法/","excerpt":"while特殊用法 遍历文件的每一行 语法 123while read line; do循环体done &lt; /PATH/FROM/SOMEFILE 执行机制","text":"while特殊用法 遍历文件的每一行 语法 123while read line; do循环体done &lt; /PATH/FROM/SOMEFILE 执行机制 依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line 练习1.扫描/etc/passwd文件每一行，如发现GECOS字段为空，则填充用户名和单位电话为62985600，并提示该用户的GECOS信息修改成功12345678910[root@centos7 scripts ]#cat GECOS.sh #!/bin/bash## while逐行读取文件内容while read line ;do ## 分别取出第一列用户名和第五列用户描述 GECOS=`echo $line|cut -d: -f5` USER=`echo $line|cut -d: -f1`## 判断如果用户描述为空，则进行填充 [ -z &quot;$GECOS&quot; ] &amp;&amp; chfn -f $USER -p 2985600 $USER &amp;&gt; /dev/null;done &lt; /etc/passwd 2.逐行读取df的信息，然后判断分区的利用率是否大于8，大于则进行警报 方法1 123456789101112131415[root@centos7 9_4 ]#cat diskcheck.sh #!/bin/bashdf |sed -n &quot;/sd/p&quot;|while read line;do name=`echo $line |tr -s &quot; &quot; %|cut -d% -f1` ## 通过echo $line对读取到的每一行进行处理 used=`echo $line |tr -s &quot; &quot; %|cut -d% -f5` if [ $used -gt 8 ];then echo &quot;$name will be full;$used %&quot; fidone[root@centos7 9_4 ]#sh diskcheck.sh/dev/sda2 will be full;9 %/dev/sda1 will be full;16 % 方法2 1234567891011121314#!/bin/bashdf |while read line;do if [[ &quot;$line&quot; =~ /dev/sd.* ]];then used=`echo $line|tr -s &quot; &quot; %|cut -d% -f5` if [ $used -gt 8 ];then echo &quot;$line&quot; |tr -s &quot; &quot; :|cut -d: -f1,5 fi fidone[root@centos7 9_4 ]#sh diskcheck1.sh /dev/sda2:9%/dev/sda1:16% 3.ss -nt查看访问连接的ip，如果达到两个，就设置防火墙策略拒绝连接。123456789101112[root@centos7 9_4 ]#vim test.sh #!/bin/bashss -nt|sed -nr &apos;/ESTAB/s/.* (.*):.*/\\1/p&apos;|sort|uniq -c|while read line;do ## 取出ip并统计次数，然后逐行读取；IP=`echo $line|cut -d&quot; &quot; -f2`num=`echo $line|cut -d&quot; &quot; -f1` if [ &quot;$num&quot; -ge 2 ];then iptables -A INPUT -s $IP -j REJECT ## 如果连接数&gt;2，则使用防火墙策略阻止连接 else true fidone","categories":[{"name":"shell","slug":"shell","permalink":"http://xinilhy.github.io/categories/shell/"}],"tags":[{"name":"shell编程","slug":"shell编程","permalink":"http://xinilhy.github.io/tags/shell编程/"}]},{"title":"shell编程之循环控制以及无限循环","slug":"shell编程之循环控制以及无限循环","date":"2018-10-05T13:03:54.000Z","updated":"2018-10-15T06:08:17.813Z","comments":true,"path":"2018/10/05/shell编程之循环控制以及无限循环/","link":"","permalink":"http://xinilhy.github.io/2018/10/05/shell编程之循环控制以及无限循环/","excerpt":"循环控制语句continue 用于循环体中 continue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层","text":"循环控制语句continue 用于循环体中 continue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层 语法 123456789while CONDTIITON1; doCMD1...if CONDITION2; thencontinuefiCMDn... done 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354## 示例1[root@centos7 9_4 ]#vim continue.sh #!/bin/bashfor i in &#123;1..10&#125;;do if [ $i -eq 5 ];then continue ## 表示i=5的时候，不再执行下面的语句，结束本次循环，开始下一次循环； fi echo i=$idone[root@centos7 9_4 ]#sh continue.sh i=1i=2i=3i=4i=6i=7i=8i=9i=10## 示例2：嵌套一个外层循环[root@centos7 9_4 ]#cat continue2.sh #!/bin/bashfor i in &#123;1..10&#125;;do for j in &#123;1..10&#125;;do if [ $j -eq 5 ];then continue ## continue后面的值默认为1，表示结束本次循环，进入下一次循环 fi echo j=$j donedone修改：continue 2[root@centos7 9_4 ]#cat continue2.sh #!/bin/bashfor i in &#123;1..10&#125;;do for j in &#123;1..10&#125;;do if [ $j -eq 5 ];then continue 2 ## 修改为2，则结束内层循环，继续外层循环 fi echo j=$j donedone[root@centos7 9_4 ]#[root@centos7 9_4 ]#sh continue2.sh j=1j=2j=3j=4j=1j=2j=3j=4 循环控制语句break 用于循环体中 break [N]：提前结束第N层循环，最内层为第1层 示例12345678910111213141516171819202122232425262728[root@centos7 9_4 ]#vim continue2.sh #!/bin/bashfor i in &#123;1..10&#125;;do for j in &#123;1..10&#125;;do if [ $j -eq 5 ];then break ## 默认值为1，类似continue 2 的效果，结束内层循环，继续外层循环 fi echo j=$j donedone修改为2：[root@centos7 9_4 ]#vim continue2.sh #!/bin/bashfor i in &#123;1..10&#125;;do for j in &#123;1..10&#125;;do if [ $j -eq 5 ];then break 2 ## 如下所示，直接结束外层和内层循环，退出脚本 fi echo j=$j donedone[root@centos7 9_4 ]#sh continue2.sh j=1j=2j=3j=4 循环控制shift命令 shift [n] 用于将参量列表 list 左移指定次数，缺省为左移一次。 参量列表 list 一旦被移动，最左端的那个参数就从列表中删除。while 循环遍历位置参量列表时，常用到 shift 示例1234567891011121314151617181920212223242526272829303132333435363738## 示例1[root@centos7 scripts ]#cat doit.sh#!/bin/bash# Name: doit.sh# Purpose: shift through command line arguments# Usage: doit.sh [args]while [ $# -gt 0 ] # or (( $# &gt; 0 ))do echo $* shiftdone执行：./doit.sh a b c d e f g h## 示例2[root@centos7 scripts ]#cat shift.sh#!/bin/bash#step through all the positional parametersuntil [ -z &quot;$1&quot; ]do echo &quot;$1&quot; shiftdoneecho执行：./shfit.sh a b c d e f g h## 示例3:[root@centos7 data ]#vim test_scripts/9_4/rm.sh #!/bin/bashwhile [ &quot;$1&quot; ];do dir=&quot;/data/backup/`date +%F`&quot; [ -d &quot;$dir&quot; ] || mkdir -p $dir [ -f &quot;$1&quot; ] &amp;&amp; mv $1 $dir &amp;&amp; echo $1 is removed shiftdoneecho &quot;done&quot; 无限循环 for语句 12for：for ((;;));do echo xin ;done while语句 123while true; do循环体done until语句 123until false; do循环体Done 当然并不是绝对的，可以利用continue和break退出循环 练习1.随机生成10以内的数字，实现猜字游戏，提示比较大或小，相等则退出 方法1 12345678910111213141516171819202122232425[root@centos7 scripts ]#cat num_size_10.sh #!/bin/bash## 生成随机数字0-9rand=`echo $[RANDOM%10]`## 创建无限循环while true;doread -p &quot;Please enter the number you guessed: &quot; num## 判断是否为数字，为真则trueif [[ $num =~ ^[0-9]+$ ]];then true## 否则，提示用户输入不正确，并退出本次循环else echo &quot;Error,Please enter the correct number&quot; continuefi if [ $num -lt $rand ];then echo &quot;you guessed the number is too small&quot; elif [ $num -gt $rand ];then echo &quot;you guessed the number is too big&quot;## 当用户猜对后，进行恭喜，并退出，返回值为0 elif [ $num -eq $rand ];then echo &quot;Congratulations, guess it.&quot; exit 0 fi done 方法2 1234567891011121314151617[root@centos7 scripts ]#cat num_size_10_1.sh #!/bin/bashrand=$[RANDOM%11] ## 生成0-10的随机数字while read -p &quot;input a number: &quot; num;do if [[ ! $num =~ ^[0-9]+$ ]];then ## 由于直接比较，不是&gt;数字的话会报错，所以进行判断; echo &quot;Please input a digit&quot; continue ## 结束本次循环 elif [ $num -gt $rand ];then echo $num is greater elif [ $num -lt $rand ];then echo $num is little else echo &quot;guess OK&quot; break ## 退出整个循环 fidone 2.用文件名做为参数，统计所有参数文件的总行数1234[root@centos7 scripts ]#cat file_line.sh #!/bin/bashline=`cat $1|wc -l`echo &quot;the $1 line is $line&quot; 3.用二个以上的数字为参数，显示其中的最大值和最小值4.每隔3秒钟到系统上获取已经登录的用户的信息；如果发现用户hacker登录，则将登录时间和主机记录于日志/var/log/login.log中,并退出脚本","categories":[{"name":"shell","slug":"shell","permalink":"http://xinilhy.github.io/categories/shell/"}],"tags":[{"name":"shell编程","slug":"shell编程","permalink":"http://xinilhy.github.io/tags/shell编程/"}]},{"title":"shelll编程之流程控制","slug":"shell编程之流程控制","date":"2018-10-04T13:03:54.000Z","updated":"2018-10-15T06:12:18.666Z","comments":true,"path":"2018/10/04/shell编程之流程控制/","link":"","permalink":"http://xinilhy.github.io/2018/10/04/shell编程之流程控制/","excerpt":"条件判断条件判断之if语句 选择执行 if语句可嵌套 单分支 123if 判断条件;then条件为真的分支代码fi","text":"条件判断条件判断之if语句 选择执行 if语句可嵌套 单分支 123if 判断条件;then条件为真的分支代码fi 双分支 12345if 判断条件; then条件为真的分支代码else条件为假的分支代码fi 多分支 123456789if 判断条件1; then条件1为真的分支代码elif 判断条件2; then条件2为真的分支代码elif 判断条件3; then条件3为真的分支代码else以上条件都为假的分支代码fi 执行机制逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句 条件判断之case语句 语法123456789101112131415161718case 变量引用 in ## 这里的变量引用即引用变量的值PAT1)分支1;;PAT2)分支2;;...*)默认分支;;esaccase支持glob风格的通配符：*: 任意长度任意字符?: 任意单个字符[]：指定范围内的任意单个字符a|b: a或b 练习1.编写脚本/root/bin/createuser.sh，实现如下功能：使用一个用户名做为参数，如果指定参数的用户存在，就显示其存在，否则添加之；显示添加的用户的id号等信息 方法1 1234567891011121314[root@centos7 scripts ]#cat createuser.sh #!/bin/bash## 判断传参个数是否为1个，不是则打印用法并退出脚本if [ $# -ne 1 ];then echo $&quot;USAGE:$0 user&quot; exit 1fi## 判断用户是否存在id $1 &amp;&gt; /dev/null ## 如果用户存在，则打印存在信息，不存在则创建[ $? -eq 0 ] &amp;&amp; echo &quot;$1 is exist&quot; || useradd $1## 人性化显示用户的id号echo &quot;$1 id is `id -u $1`&quot; 方法2 123456789101112131415[root@centos7 scripts ]#cat createuser1.sh #!/bin/bash## 以交互式方式输入用户read -p &quot;Please input user: &quot; user## 判断变量值是否为空[ $&#123;#user&#125; -le 0 ] &amp;&amp; &#123; echo &quot;you input is null&quot; exit 1&#125;## 判断用户是否存在id $user &amp;&gt; /dev/null ## 如果用户存在，则打印存在信息，不存在则创建[ $? -eq 0 ] &amp;&amp; echo &quot;$user is exist&quot; || useradd $user## 人性化显示用户的id号echo &quot;$user is `id -u $user`&quot; 2.编写脚本/root/bin/yesorno.sh，提示用户输入yes或no,并判断用户输入的是yes还是no,或是其它信息 方法1———tr转换大写为小写 12345678910111213141516[root@centos7 scripts ]#cat yesorno.sh #!/bin/bash## 思路：用户输入的所有选择：y|yes|Y|YES,同n|no|N|NO## 分析: 统一判断条件为大写或小写:tr进行转换## 使用两种选择判断：y|yes|;n|no或者大写read -p &quot;Input yes or no:&quot; answer## tr对结果进行转换成小写ans=`echo &quot;$answer&quot;|tr &apos;A-Z&apos; &apos;a-z&apos;`if [ &quot;$ans&quot; = &quot;yes&quot; -o &quot;$ans&quot; = &quot;y&quot; ];then echo &quot;YES&quot;elif [ &quot;$ans&quot; = &quot;no&quot; -o &quot;$ans&quot; = &quot;n&quot; ];then echo &quot;NO&quot;else echo &quot;Please input yes or no&quot;fi 方法2——使用正则匹配 12345678910111213141516[root@centos7 scripts ]#cat yesorno1.sh #!/bin/bash## 思路：用户输入的所有选择：y|yes|Y|YES,同n|no|N|NO## 分析: 使用正则进行匹配所有选择#!/bin/bashread -p &quot;Input yes or no:&quot; answer## 正则匹配使用[[]]，并且前面的字符串加双引号，锚定行首和行尾，?表示0或1次，即Y、y、YES、yes.if [[ &quot;$answer&quot; =~ ^[Yy]([Ee][Ss])?$ ]];then echo YES## 同理，no的选择也是n、N、no、NO、还有No、nO等elif [[ &quot;$answer&quot; =~ ^[Nn][Oo]?$ ]];then echo &quot;NO&quot;else echo &quot;Please input yes or no&quot;fi 方法3——使用case匹配 123456789101112131415161718192021[root@centos7 scripts ]#cat while_yesorno.sh #!/bin/bash## 思路：用户输入的所有选择：y|yes|Y|YES,同n|no|N|NO## 分析: 统一判断条件为大写或小写:tr进行转换## 使用两种选择判断：y|yes|;n|no或者大写#!/bin/bashread -p &quot;Please input yes or no: &quot; anscase $ans in## 匹配值[Y或y]或[Yes、YES、yes等]，|为或的意思[Yy]|[Yy][Ee][Ss]) echo YES ;;## 匹配[N或n]或[NO、no、No、nO][Nn]|[Nn][Oo]) echo NO ;;*) echo input false ;;esac 3.编写脚本/root/bin/filetype.sh,判断用户输入文件路径，显示其文件类型（普通，目录，链接，其它文件类型） 方法1 1234567891011121314151617181920212223242526[root@centos7 scripts ]#cat filetype.sh #!/bin/bashread -p &quot;Please input a file_path: &quot; file_path## 判断变量值是否为空[ $&#123;#file_path&#125; -le 0 ] &amp;&amp; &#123; echo &quot;you input is null&quot; exit 1&#125;## ls -ld 显示文件或目录的详细信息，head取第一个字节，即文件类型标识head_file=`ls -ld $file_path|head -c1`## case对标识进行匹配，并人性化显示文件类型case $head_file in-) echo &quot;this $file_path is file&quot; ;;d) echo &quot;this $file_path is directory&quot; ;;l) echo &quot;this $file_path is link &quot; ;;*) echo &quot;this $file_path is other filetype&quot; ;;esac 方法2: 1234567891011121314151617[root@centos7 scripts ]#cat filetype1.sh #!/bin/bashread -p &quot;Please input a file_path: &quot; file_path## 判断变量值是否为空[ $&#123;#file_path&#125; -le 0 ] &amp;&amp; &#123; echo &quot;you input is null&quot; exit 1&#125;if [ -f $file_path ];then echo &quot;this $file_path is file&quot;elif [ -d $file_path ];then echo &quot;this $file_path is directory&quot;elif [ -L $file_path ];then echo &quot;this $file_path is link &quot;else echo &quot;this $file_path is other filetype&quot;fi 4.编写脚本/root/bin/checkint.sh,判断用户输入的参数是否为正整数 方法1123456789101112131415[root@centos7 scripts ]#cat checkint.sh #!/bin/bashread -p &quot;Please input a Positive integer: &quot; num## 判断变量值是否为空[ $&#123;#num&#125; -le 0 ] &amp;&amp; &#123; echo &quot;you input is null&quot; exit 1&#125;## 判断是否为整数,是则打印输出，否则提示if [ &quot;num&quot; =~ ^[1-9][0-9]*$ &amp;&gt; /dev/null ];then echo &quot;you input is $num&quot;else echo &quot;Please input a Positive integer&quot; exit 1 fi 循环 将某代码段重复运行多次 重复运行多少次 循环次数事先已知 循环次数事先未知 有进入条件和退出条件 有for, while, until 循环之for语句 语法 123for 变量名 in 列表;do循环体done 执行机制 1依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束 列表生成方式 123456789(1) 直接给出列表(2) 整数列表：(a) &#123;start..end&#125;(b) $(seq [start [step]] end)(3) 返回列表的命令 $(COMMAND)(4) 使用glob，如：*.sh(5) 变量引用； $@, $* 循环之while循环 语法 123while CONDITION; do循环体done CONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环 因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正 进入条件：CONDITION为true 退出条件：CONDITION为false 循环之until循环 语法 123until CONDITION; do循环体done 进入条件： CONDITION 为false 退出条件： CONDITION 为true 练习for语句练习1.判断/var/目录下所有文件的类型 方法1 1234567891011121314[root@centos7 scripts ]#cat var_filetype.sh #!/bin/bash## 利用for+if进行匹配文件类型for files in /var/* ;do if [ -f $files ];then echo &quot;$files exists and is a regular file.&quot; elif [ -h $files ] ;then echo &quot;$files is a symbolic link.&quot; elif [ -d $files ] ;then echo &quot;$files is a directory.&quot; else echo &quot;$files is others.&quot; fidone 方法2 1234567891011121314151617181920212223[root@centos7 scripts ]#cat var_filetype2.sh #!/bin/bash## 利用for+case进行匹配文件类型## 首先利用for循环读取每个文件for files in /var/* ;do## 取每个文件属性信息的第一个字节 file_type=`ls -ld $files|head -c1`## case匹配 case $file_type in -) echo &quot;$files exists and is a regular file.&quot; ;; l) echo &quot;$files is a symbolic link.&quot; ;; d) echo &quot;$files is a directory.&quot; ;; *) echo &quot;$files is others.&quot; ;; esacdone 添加10个用户user1-user10，密码为8位随机字符12345678[root@centos7 scripts ]#cat user1_10.sh #!/bin/bashfor i in &#123;1..10&#125;;do useradd user$i ran_pss=`openssl rand -base64 8|tr -dc [0-9a-zA-Z]|head -c8` echo &quot;$ran_pss&quot; |passwd --stdin user$i &amp;&gt; /dev/nulldone 3.删除用户1[root@centos7 scripts ]#tail -10 /etc/passwd|cut -d: -f1|while read line;do userdel -r $line;done 4./etc/rc.d/rc3.d目录下分别有多个以K开头和以S开头的文件；分别读取每个文件，以K开头的输出为文件加stop，以S开头的输出为文件名加start，如K34filename stopS66filename start 方法1 1234567891011121314[root@centos7 scripts ]#cat rc.sh #!/bin/bash## 从/etc/rc.d/rc3.d/中读取每个文件for i in /etc/rc.d/rc3.d/*;do## 取文件的基名，即仅取最后的文件名 value=`basename $i`## 正则匹配，如果是以K开头，则添加stop if [[ &quot;$value&quot; =~ ^K ]];then echo &quot;$i stop&quot;## 否则，以S开头，则添加start elif [[ &quot;$value&quot; =~ ^S ]];then echo &quot;$i start&quot; fidone 方法2 1234567891011121314[root@centos7 scripts ]#cat rc1.sh #!/bin/bash## 从/etc/rc.d/rc3.d/中读取每个文件for i in /etc/rc.d/rc3.d/*;do## 取文件的基名，即仅取最后的文件名 value=`basename $i|head -c1`## 正则匹配，如果是以K开头，则添加stop if [ &quot;$value&quot; == K ];then echo &quot;$i stop&quot;## 否则，以S开头，则添加start elif [ &quot;$value&quot; == S ];then echo &quot;$i start&quot; fidone 编写脚本，提示输入正整数n的值，计算1+2+…+n的总和 scripts ]#cat num_sum.sh 1234567891011121314151617181920#!/bin/bashsum=0read -p &quot;Please input 一个正整数：&quot; num## 判断是否为空,如果为空，则输出提示信息，并退出if [ $&#123;#num&#125; -le 0 ];then echo &quot;Error,you input is null&quot; exit 1fi## 判断是否为正整数if [[ $num =~ ^[1-9][0-9]*$ ]];then## 生成列表有&#123;&#125;和seq两种方式，但是&#123;&#125;赋值后仅仅不生成列表，还好seq支持； for i in `seq 1 $num`;do let sum+=$i ## 记住，计算的时候一定要添加相应的命令，不可以直接 sum+=$i done echo &quot;sum=$sum&quot;else ## 如果不是一个正整数，则输出警告信息，并退出 echo &quot;Error,you input is not positive integer&quot; exit 1fi 计算100以内所有能被3整除的整数之和 方法1 1234567891011121314[root@centos7 scripts ]#cat 100_3num.sh #!/bin/bashsum=0## for从1到100中循环取值for i in &#123;1..100&#125;;do## 求出每个数与3计算后的余数 value=`echo $[$i%3]`## 如果余数为0，则进行求和计算，否则，不显示if [ $value -eq 0 ];then let sum+=$ifidone## 打印最后的和echo &quot;sum=$sum&quot; 方法2 12345678910[root@centos7 scripts ]#cat 100_3num1.sh #!/bin/bashsum=0## 由于必须被3整除，所以定义开始为3，步进为3的整数列表，i循环取值并计算求和for i in `seq 3 3 100` ;do## 对取值进行计算求和 let sum+=idone## 打印最后的结果echo &quot;sum=$sum&quot; 编写脚本，提示请输入网络地址，如192.168.0.0，判断输入的网段中主机在线状态 方法1 12345678910111213141516171819[root@centos7 scripts ]#cat scanip.sh #!/bin/bashread -p &quot;Please input a network address(eg:192.168.0.0): &quot; netid## 取出前三位的网络IDip_head=`echo $netid|cut -d. -f1-3`## 对最后一位进行匹配1..254for i in &#123;1..254&#125;;do## 组合成一个完整的ipip=$ip_head.$i## &#123;&#125;&amp;是为了并行执行更加快速&#123; ping -c1 $ip &amp;&gt; /dev/nullif [ $? -eq 0 ];then echo &quot;$ip is up&quot;else echo &quot;$ip is down&quot;fi &#125; &amp;done## 结尾添加wait自动退出，否则需要手动敲击enter退出wait 方法2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[root@centos7 scripts ]#cat scanip1.sh while true; do read -t 60 -p &quot;input the network number: &quot; netnum if [[ $netnum =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.)&#123;3]];then break else echo wrong network number fi donelast=$(echo $netnum|cut -d&apos;.&apos; -f3)declare -i up=0declare -i down=0if [ $last != 0 ];then net=$(echo $netnum|cut -d&apos;.&apos; -f1-3) for i in &#123;1..255&#125;;do j=$&#123;net&#125;.$i &#123; if ping -c1 -w1 $j &amp;&gt;/dev/null;then echo host $j is up let up++ else #echo host $j is down let down++ fi; &#125; &amp; done wait #echo #echo -e &quot;uphost number is:\\t $up&quot; #echo -e &quot;downhost number is:\\t $down&quot;else second=$(echo $netnum |cut -d&apos;.&apos; -f2) if [ $second = 0 ];then echo I cant do this. Its a too much big network exit 2 else net=$(echo $netnum |cut -d&apos;.&apos; -f1-2) for i in `seq 0 255`;do j=$&#123;net&#125;.$i for k in `seq 0 255`;do &#123; h=$&#123;j&#125;.$k if ping -c1 -w1 $h &amp;&gt;/dev/null;then echo host $h is up let up++ else #echo host $h is dowm let down++ fi; &#125; &amp; done wait done #echo #echo -e &quot;uphost number is:\\t $up&quot; #echo -e &quot;downhost number is:\\t $down&quot; fifi 打印九九乘法表 方法1 1234567891011121314[root@centos7 scripts ]#cat 99.sh #!/bin/bash## 约定如下：## 第一个数字为列数，定义为j；## 第二个数字为行数，定义为i；## 首先先打印一行，然后循环打印行数即可；## 那一行：循环次数是多少？找规律，列数&lt;=行数for ((i=1;i&lt;=9;i++));do for ((j=1;j&lt;=i;j++));do## -e解释特殊字符，\\t是tab键，\\c是不换行，或者直接使用-n也可以； echo -e &quot;$j*$i=$[j*i]\\t\\c&quot; done echo done 方法2 1234567891011121314151617181920212223242526[root@centos7 scripts ]#cat 99_1.sh #!/bin/bash## 约定如下：## 第一个数字为列数，定义为j；## 第二个数字为行数，定义为i；## 首先先打印一行，然后循环打印行数即可；## 那一行：循环次数是多少？找规律，列数&lt;=行数#for ((i=1;i&lt;=9;i++));do# for ((j=1;j&lt;=i;j++));do## -e解释特殊字符，\\t是tab键，\\c是不换行，或者直接使用-n也可以；# echo -e &quot;$j*$i=$[j*i]\\t\\c&quot;# done# echo #donei=1while [ $i -le 9 ];do j=1 while [ $j -le $i ];do echo -e &quot;$j*$i=$[j*i]\\t\\c&quot; let j++done let i++ echo done 在/testdir目录下创建10个html文件,文件名格式为数字N（从1到10）加随机8个字母，如：1AbCdeFgH.html 方法1 123456789[root@centos7 scripts ]#cat ran_html.sh #!/bin/bash## 判断目录是否存在，存在则进入，否则创建并进入[ -d /testdir ] || mkdir /testdirfor i in &#123;1..10&#125;;do## 注意；这个命令应该放在for循环里，每次执行生成的随机字符都不一样rand=`openssl rand -base64 8|tr -dc [a-zA-Z]|head -c8` touch /testdir/$&#123;i&#125;$rand.htmldone 方法2 123456789[root@centos7 scripts ]#cat ran_html1.sh #!/bin/bash## 判断目录是否存在，存在则进入，否则创建并进入[ -d /testdir ] || mkdir /testdirfor ((i=1;i&lt;=10;i++));do## 注意；这个命令应该放在for循环里，每次执行生成的随机字符都不一样rand=`openssl rand -base64 8|tr -dc [a-zA-Z]|head -c8` touch /testdir/$&#123;i&#125;$rand.htmldone 10.打印等腰三角形 方法1：利用while实现 1234567891011121314151617181920212223242526272829[root@centos7 scripts ]#cat I_triangle.sh #!/bin/bash## 约定如下## 定义总行数：line## 当前行:i## 当前列:j## 中间*所在列=总行数line## 当前行*从开头到中间的个数=当前行i## space=总行数line-当前行数i## 当前行*的个数：2i-1read -p &quot;Please input a line number: &quot; linei=1 ## 打印多行while [ &quot;$i&quot; -le &quot;$line&quot; ];do ## print space ## 打印空格 j=1 while [ &quot;$j&quot; -le $[line-i] ];do echo -n &quot; &quot; ## 或者使用 echo -e &quot; \\c&quot; let j++ done ## print * ## 打印*的个数 k=1 while [ &quot;$k&quot; -le $[2*i-1] ];do echo -n &quot;*&quot; let k++ done let i++ echo done 方法2 123456789101112131415161718192021222324252627[root@centos7 scripts ]#cat for_triangle.sh #!/bin/bash## 约定如下## 定义总行数：line## 当前行:i## 当前列:j## 中间*所在列=总行数line## 当前行*从开头到中间的个数=当前行i## space=总行数line-当前行数i## 当前行*的个数：2i-1## 利用for的第二种语法实现：#!/bin/bashread -p &quot;Please input a line number: &quot; linefor ((i=1;i&lt;=line;i++));do## 打印空格 for ((j=1;j&lt;=$[line-i];j++));do echo -n &quot; &quot; done## 打印*的个数 for ((k=1;k&lt;=$[2*i-1];k++));do echo -n &quot;*&quot; done## 打印完一行后进行换行 echo done while语句练习 编写脚本，求100以内所有正奇数之和 方法1 1234567[root@centos7 scripts ]#cat odd_number_100.sh #!/bin/bashsum=0for i in &#123;1..10..2&#125;;do let sum+=$idoneecho &quot;sum=$sum&quot; 方法2 12345678910111213[root@centos7 scripts ]#cat while_odd_number_100.sh #!/bin/bash## 如果sum赋值为1，则下面计算sum和i的顺序需要调整为：i在前，sum在后sum=0 ## 对于while语句来说，需要定义初始值、条件、以及不断变化的值i=1while [ $i -le 100 ];do let sum+=$i## 由于是奇数，所以i=i+2;i++即所谓的i=i+1 let i+=2doneecho &quot;sum=$sum&quot; 2.编写脚本，打印九九乘法表 12345678910111213141516171819[root@centos7 scripts ]#cat while_99.sh #!/bin/bash## 约定如下：## 第一个数字为列数，定义列数为j,i&lt;=i## 第二个数字为行数，定义行数为i,i&lt;=9## 思路：先打印一行，然后循环打印多行，一行循环次数的规律是:j&lt;=ii=1while [ $i -le 9 ];do j=1 while [ $j -le $i ];do echo -e &quot;$j*$i=$[j*i]\\t\\c&quot;##\\t表示插入tab,\\c表示不换行，需要使用-e选项；或者直接-n选项也是不换行 let j++done let i++ echo## echo 表示打印一行后进行换行 done 编写脚本，利用变量RANDOM生成10个随机数字，输出这个10数字，并显示其中的最大值和最小值 方法1 scripts ]#cat ran_10.sh 12345678910111213141516171819202122232425262728293031#!/bin/bash## 打印随机数列表并且不换行echo -n &quot;rand_list: &quot;## 循环生成10个数字i=1while [ $i -le 10 ];do rand=`echo $RANDOM`## 每循环一次输出一个随机数，并且不换行显示 echo -e &quot;$rand\\t\\c&quot;## 如果第一次打印，则没有其他数字可以比较，这时最大和最小都是自己 if [ $i -eq 1 ];then max=$rand min=$rand fi## 如果随机数大于当前最大值，则把随机数替换为目前最大值 if [ $max -lt $rand ];then max=$rand## 如果随机数小于当前最小值，则进行替换 elif [ $min -gt $rand ];then min=$rand## 对于其他情况保持true，默认 else true fi let i++doneecho ## 打印完所有随机数后进行换行## 输出最大值和最小值echo max is $maxecho min is $min 方法2 12345678910111213[root@centos7 scripts ]#cat ran_10_1.sh #!/bin/bash## 定义存储随机数的文件file=/data/ran.txt## 每次执行脚本之前清空文件，否则会保留原来的数据&gt; $filefor((i=1;i&lt;=10;i++));do## 循环追加随机数到文件中 echo $RANDOM &gt;&gt; $filedone## 利用sort进行排序，取最大值和最小值echo max `cat $file|sort -nr|head -1`echo min `cat $file|sort -nr|tail -1` 编写脚本，实现打印国际象棋棋盘 方法1 1234567891011121314151617181920212223242526272829303132333435363738394041[root@centos7 scripts ]#cat International_chess.sh #!/bin/bash## 国际象棋：8行8列## 定义行数为i；列数为j## 思路：奇数行——————红绿红绿红绿红绿； 奇数列===红; 偶数列===绿## 偶数行——————绿红绿红绿红绿红； 奇数列===绿；偶数列===红## 判断奇数行的奇数列和偶数列分别打印什么颜色；偶数行的奇数列和偶数列分别打印什么颜色； ## 定义行的循环，循环8次for((i=1;i&lt;=8;i++));do## 对2进行取模，判断是奇数行还是偶数行 i_value=`echo $[i%2]`## 如果是奇数行，则直接执行下面打印行的操作 if [ $i_value -ne 0 ];then## 定义一行，一列循环8次 for((j=1;j&lt;=8;j++));do## 对2进行取模，判断是奇数列还是偶数列 j_value=`echo $[j%2]`## 如果是偶数列，则打印绿色，注意不换行 if [ $j_value -eq 0 ];then echo -e &quot;\\e[42m \\e[0m\\c&quot;## 否则对于奇数列，则打印红色，注意，不换行 else echo -e &quot;\\e[41m \\e[0m\\c&quot; fi done## 打印完一行后进行换行 echo## 对应第9行，如果是偶数行，则执行下面的语句，颜色和奇数行正好相反； else for((j=1;j&lt;=8;j++));do j_value=`echo $[j%2]` if [ $j_value -eq 0 ];then echo -e &quot;\\e[41m \\e[0m\\c&quot; else echo -e &quot;\\e[42m \\e[0m\\c&quot; fi done echo fidone 方法2 1234567891011121314151617181920212223242526272829303132333435363738394041[root@centos7 scripts ]#cat International_chess1.sh #!/bin/bash## 国际象棋：8行8列## 定义行数为i；列数为j## 思路2： ## 第一行===红绿红绿红绿红绿## 第二行===绿红绿红绿红绿红 ## 打印一行奇数行偶数行，然后循环4次；for ((k=1;k&lt;=4;k++));do for ((i=1;i&lt;=2;i++));do if [ $i -eq 1 ];then for ((j=1;j&lt;=8;j++));do j_value=`echo $[j%2]`## 如果是偶数列，则打印绿色，注意不换行 if [ $j_value -eq 0 ];then echo -e &quot;\\e[42m \\e[0m\\c&quot;## 否则对于奇数列，则打印红色，注意，不换行 else echo -e &quot;\\e[41m \\e[0m\\c&quot; fi done## 打印完一行后进行换行 echo else for ((j=1;j&lt;=8;j++));do j_value=`echo $[j%2]`## 如果是偶数列，则打印绿色，注意不换行 if [ $j_value -eq 0 ];then echo -e &quot;\\e[41m \\e[0m\\c&quot;## 否则对于奇数列，则打印红色，注意，不换行 else echo -e &quot;\\e[42m \\e[0m\\c&quot; fi done## 打印完一行后进行换行 echo fi donedone 国际象棋巨无霸版 123456789101112131415161718192021222324252627282930313233343536373839[root@centos7 scripts ]#cat International_chess_big.sh #!/bin/bash##思路：## 第五步：循环8次，打印大的方块行for((n=1;n&lt;=8;n++));do## 第六步：取模，判断奇数行还是偶数行，然后输出对应的方块行； value=`echo $[n%2]` if [ $value -ne 0 ];then## 第四步：再以更大的循环，循环4次，打印前4行，即出现大的方块===黄绿黄绿黄绿黄绿 for ((k=1;k&lt;=4;k++));do## 第三步:以大的循环，循环4次，打印第一行； for ((i=1;i&lt;=4;i++));do## 第一步:先循环输出4个小黄色方块； for((j=1;j&lt;=4;j++));do echo -e &quot;\\e[43m \\e[0m\\c&quot; done## 第二步:循环输出4个小蓝色方块； for((j=1;j&lt;=4;j++));do echo -e &quot;\\e[44m \\e[0m\\c&quot; done done## 换行 echo done## 对应上面的第六步，if判断，这里为偶数行对应的方块颜色,其他同上 else for ((k=1;k&lt;=4;k++));do for ((i=1;i&lt;=4;i++));do for((j=1;j&lt;=4;j++));do echo -e &quot;\\e[44m \\e[0m\\c&quot; done for((j=1;j&lt;=4;j++));do echo -e &quot;\\e[43m \\e[0m\\c&quot; done done echo done fidone 后续六个字符串：efbaf275cd、4be9c40b8b、44b2395c46、f8c8873ce0、b902c16c8b、ad865d2f63是通过对随机数变量RANDOM随机执行命令： echo $RANDOM|md5sum|cut –c1-10 后的结果，请破解这些字符串对应的RANDOM值 方法1 1234567891011[root@centos7 scripts ]#cat pojie.sh #!/bin/bashsum=&quot;efbaf275cd 4be9c40b8b 44b2395c46 f8c8873ce0 b902c16c8b ad865d2f63&quot;for i in &#123;0..32767&#125;;dotest_num=`echo $i|md5sum|cut -c 1-10` for num in $sum;do if [ &quot;$test_num&quot; == &quot;$num&quot; ];then echo &quot;$num-----$i&quot; fi donedone 方法2 1234567891011121314151617181920[root@centos7 scripts ]#cat pojie1.sh #!/bin/bash## 首先将0-32767内的所有数字通过md5sum加密，然后把加密后的字符串和加密前的数字对应的写入日志中&gt; /tmp/random.logfor i in &#123;0..32767&#125;do echo &quot;`echo $i|md5sum ` $i&quot; &gt;&gt; /tmp/random.logdone## 定义已经给出的加密的字符串md5_sum=efbaf275cdwhile read linedo## 循环日志中的每一行进行过滤，如果符合要求，则wc后的值为1 if [ `echo $line|grep &quot;$md5_sum&quot;|wc -l` -eq 1 ];then## 打印查找到的行 echo $line # break fidone &lt; /tmp/random.log ## 读取加密后的日志文件 until语句练习 每隔3秒钟到系统上获取已经登录的用户的信息；如果发现用户hacker登录，则将登录时间和主机记录于日志/var/log/login.log中,并退出脚本 方法1 12345678[root@centos7 scripts ]#cat hacker.sh #!/bin/bash## 判断用户是否是否登录，until语句条件为真则退出循环；条件为假则执行循环until who|grep -q &quot;^hacker\\&gt;&quot;;do sleep 3done ## 如果有hacker用户在登录，则退出循环，并执行下面的pkill语句。pkill -9 -U hacker ## 注意 pkill -9 可以杀死用户所有的进程。 方法2 1234567[root@centos7 scripts ]#cat hacker1.sh ## 优化版：不退出脚本，进入死循环，hacker一旦登录，则直接踢出去#!/bin/bash until false; do ## 由于until语句为假则执行循环体，即一旦hacker登录，就立即踢出去，并且这里为死循环 who|grep -q &quot;^hacker\\&gt;&quot; &amp;&amp; pkill -9 -U hacker sleep 3done","categories":[{"name":"shell","slug":"shell","permalink":"http://xinilhy.github.io/categories/shell/"}],"tags":[{"name":"shell编程","slug":"shell编程","permalink":"http://xinilhy.github.io/tags/shell编程/"}]},{"title":"shell编程之入门","slug":"shell编程之入门","date":"2018-10-03T13:03:54.000Z","updated":"2018-10-15T06:25:44.153Z","comments":true,"path":"2018/10/03/shell编程之入门/","link":"","permalink":"http://xinilhy.github.io/2018/10/03/shell编程之入门/","excerpt":"shell编程结构：各种系统命令的组合 数据存储：变量、数组 表达式: a + b 语句:if 、case、for、while、until等","text":"shell编程结构：各种系统命令的组合 数据存储：变量、数组 表达式: a + b 语句:if 、case、for、while、until等 shell脚本创建： 第一行必须声明shell：#!/bin/bash可以添加注释，以#开头 规范：1、第一行一般为调用使用的语言2、程序名，避免更改文件名为无法找到正确的文件3、版本号4、更改后的时间5、作者相关信息6、该程序的作用，及注意事项7、最后是各版本的更新简要说明 执行： 给x权限，然后使用绝对、相对路径执行；或者添加到PATH变量中，直接文件名执行。 直接调用bash执行； source或. echo … | bash （后期可以下载互联网上的脚本给bash） 脚本调试 检测语法：sh -n调试执行：sh -x 变量 就是一段命名的内存空间 支持的类型：字符型、数值型：整型、浮点型 由于shell是弱类型语言，不需要指定类型；并且bash 不支持浮点数 命名 不能使用程序中的保留字，如if、for 只能使用数字、字母及下划线，且不能以数字开头 命名需要人性化，见名知义 使用驼峰命名法，如studentName 分类 局部：生效范围为当前shell进程；对当前shell之外的其它shell进程，包括 当前shell的子shell进程均无效 环境：生效范围为当前shell进程及其子进程 只读: 位置变量：$1, $2, …来表示，用于在shell脚本中引用命令行传入的参数； 特殊变量：$?, $0, $*, $@, $#,$$ 局部变量 赋值： 普通字符串：name=”value“ 变量引用：name=”$USER” 命令：name=cmd name=$(cmd) 文件路径：filename=/etc/fstab 变量引用： “” ：直接引用变量值 ‘’ ：保持原字符串显示所有已定义的变量————set删除变量——————————unset name 练习： 编写脚本/root/bin/systeminfo.sh,显示当前主机系统信息，包括主机名， IPv4地址，操作系统版本，内核版本，CPU型号，内存大小，硬盘大小1234567891011121314151617[root@centos7 test]#cat systeminfo.sh #!/bin/bashecho &quot;My hostname is ` hostname`&quot;echo &quot;os version is:`cat /etc/centos-release`&quot;echo &quot;kernel version is `uname -r`&quot;echo &quot;CPU type:`lscpu | grep &quot;Model name&quot; | tr -s &quot; &quot; | cut -d: -f2`&quot;echo &quot;meminfo:`cat /proc/meminfo|head -1|tr -s &quot; &quot;|cut -d: -f2 `&quot;echo &quot;Disk:`lsblk|grep &quot;^sd&quot;|tr -s &quot; &quot;|cut -d&quot; &quot; -f1,4`&quot;echo &quot;My username is $USER&quot;[root@centos7 test]#sh systeminfo.sh My hostname is centos7.localdomainos version is:CentOS Linux release 7.5.1804 (Core) kernel version is 3.10.0-862.el7.x86_64CPU type: Intel(R) Core(TM) i5-4210U CPU @ 1.70GHzmeminfo: 1258076 kBDisk:sda 200GMy username is root 编写脚本/root/bin/backup.sh，可实现每日将/etc/目录备份到/root/etcYYYY-mm-dd中 123456[root@centos7 test]#cat backup.sh #!/bin/bashcp -a /etc/ /root/etc`date +%F` &amp;&amp; echo &quot;backup is ok&quot; || echo &quot;backup is err&quot;[root@centos7 test]#sh backup.sh backup is ok[root@centos7 test]# 编写脚本/root/bin/disk.sh,显示当前硬盘分区中空间利用率最大的值 12345[root@centos7 test]#cat disk.sh #!/bin/bashecho &quot;Disk is `df -h|tr -s &quot; &quot; %|cut -d% -f5|sort -nr|head -1`&quot;[root@centos7 test]#sh disk.sh Disk is 16 编写脚本/root/bin/links.sh,显示正连接本主机的每个远程主机的IPv4地址和连接数，并按连接数从大到小排序 环境变量声明和赋值： export name=VALUE declare -x name=VALUE 引用： $name 或 ${name} 其中，${name}用于区分变量和后面的字符，如：$(name)01 显示所有环境变量： env export 删除： unset name 只读变量特点：只能声明，但是不能修改和删除 声明： readonly name declare -r name 查看： readonly -p 位置变量在脚本中调用命令行传入的参数 $1, $2, …：对应第1、第2等参数，shift [n]换位置特殊变量 $0: 命令本身 $*: 传递给脚本的所有参数，全部参数合为一个字符串 $@: 传递给脚本的所有参数，每个参数为独立字符串 注意： ZHY$@ $* 只在被双引号包起来的时候才会有差异 $#: 传递给脚本的参数的个数 $?：保存上一条命令的执行状态（0 代表成功，1－255代表失败） set – 清空所有位置变量 退出状态码exit [n]：自定义退出状态码 注意：如果在脚本中指定状态码，脚本在执行过程中一旦遇到exit命令，立即终止；退出状态由exit后的数字决定。 如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码（即：如果前面有错误的命令，但是最后是执行成功的，那么状态码依然是0） 算术运算： +, -, *, /, %取模（取余）, **（乘方） 实现方法： let var=算术表达式 var=$ [算术表达式] var=$((算术表达式)) ((a=1+3));echo $a echo “算术表达式” |bc var=$(expr arg1 arg2 arg3 …) (注意空格) 注意：乘法符号在有些场景下需要转义,如* 123456789 方法一：[root@centos7 ~]#x=1[root@centos7 ~]#y=2[root@centos7 ~]#let sum=x+y[root@centos7 ~]#echo $sum3方法二：[root@centos7 ~]#echo $[x*y]2 赋值： +=，-=,*=,/=,%= 例如：let count+=3,即自加3后赋值给自己。 1234 [root@centos7 data 19:58:15]$count=10[root@centos7 data 20:45:31]$let count+=3[root@centos7 data 20:45:38]$echo $count13 自增、自减： 12let var+=1=====let var++let var-=1=====let var-- 练习： 编写脚本/root/bin/sumid.sh，计算/etc/passwd文件中的第10个用户和第20用户的ID之和 123uid10=`head /etc/passwd|tail -n1|cut -d: -f3`uid20=`head -20 /etc/passwd|tail -n1|cut -d: -f3`echo &quot;sumid is $[uid10+uid20]&quot; 编写脚本/root/bin/sumspace.sh，传递两个文件路径作为参数给脚本，计算这两个文件中所有空白行之和 12345space1=`grep &quot;^$&quot; $1|wc -l `echo &quot;$1 is $space1&quot;space2=`grep &quot;^$&quot; $2|wc -l `echo &quot;$2 is $space2&quot;echo &quot;$[space1+space2]&quot; 编写脚本/root/bin/sumfile.sh,统计/etc,/var, /usr目录中共有多少个一级子目录和文件 1234567dirsum1=`ls -l $1|wc -l`echo &quot;$1 dirnum is $dirsum1&quot;dirsum2=`ls -l $2|wc -l`echo &quot;$2 dirnum is $dirsum2&quot;dirsum3=`ls -l $3|wc -l`echo &quot;$3 dirnum is $dirsum3&quot;echo &quot;is $[dirsum1+dirsum2+dirsum3]&quot; 逻辑运算： true —-1 （总是成功）false—-0 （总是失败）123456[root@centos7 mnt]# true [root@centos7 mnt]# echo $?0[root@centos7 mnt]# false[root@centos7 mnt]# echo $?1 注意：这里的1和0和前面的$?不一样，不要混淆。 与：1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0 即：和1与的保留原值； 和0与的都为0 例如：十进制12&amp;8在与的时候需要转换成二进制，分别为1100和1000，想与即1000；123[root@centos7 ~]#((a=12&amp;8))[root@centos7 ~]#echo $a8 或： 123451 或 1 = 11 或 0 = 10 或 1 = 10 或 0 = 0即：和1或的都为1，和0或的保持原值不变。 非：123非：！ ! 1 = 0 ! 0 = 1 123456[root@centos7 mnt]# ! true[root@centos7 mnt]# echo $?1[root@centos7 mnt]# ! false[root@centos7 mnt]# echo $?0 短路运算：短路与：12345表达式：cmd1 &amp;&amp; cmd2如果cmd1成功，则执行cmd2如果cmd1失败，则不执行cmd2 原理： 当cmd1为真，则整体的真假由后面的cmd2判断； 当cmd2为假，整体为假； 123测试：如果文件存在，则添加x权限；ls anaconda-ks.cfg &amp;&gt; /dev/null &amp;&amp; chmod +x anaconda-ks.cfg 短路或：12345表达式：cmd1 || cmd2如果cmd1成功，则不执行cmd2如果cmd1失败，则执行cmd2 123456789101112测试：案例1：如果用户不存在，则创建该用户：[root@centos7 mnt]# id wan &amp;&gt; /dev/null || useradd wan案例2：如果用户不存在，则创建该用户，并输出创建提示；[root@centos7 mnt]# id wan &amp;&gt; /dev/null || ( useradd wan &amp;&gt; /dev/null ; echo wan is created )wan is created 案例3：如果用户不存在，则创建该用户，并输出创建提示；否则当用户存在时，提示；[root@centos7 mnt]# name=mage; id $name &amp;&gt; /dev/null &amp;&amp; echo $name is exist || ( useradd $name &amp;&gt; /dev/null ; echo $name is created )mage is created [root@centos7 mnt]# name=mage; id $name &amp;&gt; /dev/null &amp;&amp; echo $name is exist || ( useradd $name &amp;&gt; /dev/null ; echo $name is created )mage is exist 异或：^异或：相同为0，不同为1； （1为真）同或：相同为1，不同为0；1234567891011121312^8=?110010000100=4案例：[root@centos7 test]$ echo $[ 12^8 ]4用途：对调数字a^b=c;a^c=b;b^c=a可以通过异或来对调数字，但是不支持字母 条件测试： 测试命令：123test EXPRESSION[ EXPRESSION ][[ EXPRESSION ]] note:EXPRESSION前后必须有空白字符！ 若真，则返回0 若假，则返回1 1234567891011121314151617181.判断centos版本号，然后使用相关命令启动服务；[root@centos7 ~]#grep -oE &quot;[[:digit:]]+&quot; /etc/centos-release|head -n17[root@centos7 ~]#version=&apos;grep -oE &quot;[[:digit:]]+&quot; /etc/centos-release|head -n1&apos;[root@centos7 ~]#[ $version -eq 6 ] &amp;&amp; service network restart[root@centos7 ~]#[ $version -eq 7 ] &amp;&amp; systemctl restart network2.测试主机是否存活？[root@centos7 ~]#ip=192.168.1.1[root@centos7 ~]#ping -c1 $ip &amp;&gt; /dev/null &amp;&amp; echo &amp;ip is up || echo &amp;ip is down3.如果cmd1成功，就执行cmd2，如果cmd2失败，就执行cmd3——————————cmd1 &amp;&amp; cmd2 || cmd3——————————[root@centos7 ~]#name=xin[root@centos7 ~]#id -u name &amp;&gt; /dev/null &amp;&amp; echo name is exist || echo name is not existname is not exist 注意:下面这个逻辑关系不常用12345——————————cmd1 || cmd2 &amp;&amp; cmd3——————————————即：如果cmd1成功，就不执行cmd2，————cmd3执行； 如果cmd1失败，就会执行cmd2，————cmd3执行； 由于cmd3总执行，所以一般不用这种逻辑关系； 测试类型： 数值测试 字符串测试 文件测试 数值型 -gt 是否大于 -ge 是否大于等于 -eq 是否等于 -ne 是否不等于 -lt 是否小于 -le 是否小于等于 字符串类型 ==：是否等于，不加“”，支持通配符 >: 是否大于 &lt; : 是否小于 !=：是否不等于 =~：匹配字符串，不加“”， 【一般用于[[]]中，支持扩展的正则表达式】 -z “string”：测试字符串是否为空，空则为真，不空则为假； -n “string”：测试字符串是否不空，不空则为真，空则为假； 注意：字符串比较时加引号； 练习:1、编写脚本/root/bin/argsnum.sh，接受一个文件路径作为参数；如果参数个数小于1，则提示用户“至少应该给一个参数”，并立即退出；如果参数个数不小于1，则显示第一个参数所指向的文件中的空白行数2、编写脚本/root/bin/hostping.sh，接受一个主机的IPv4地址做为参数，测试是否可连通。如果能ping通，则提示用户“该IP地址可访问”；如果不可ping通，则提示用户“该IP地址不可访问”3、编写脚本/root/bin/checkdisk.sh，检查磁盘分区空间和inode使用率，如果超过80%，就发广播警告空间将满 文件测试：存在性测试-a FILE：同-e-e FILE: 文件存在性测试，存在为真，否则为假 存在性及类别测试-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h FILE 或 -L FILE：存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件 文件权限测试-r FILE：是否存在且可读-w FILE: 是否存在且可写-x FILE: 是否存在且可执行 文件特殊权限测试-u FILE：是否存在且拥有suid权限-g FILE：是否存在且拥有sgid权限-k FILE：是否存在且拥有sticky权限 文件大小测试-s FILE: 是否存在且非空 文件是否打开-t fd: fd 文件描述符是否在某终端已经打开-N FILE：文件自从上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组 双目测试FILE1 -ef FILE2: FILE1是否是FILE2的硬链接FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）FILE1 -ot FILE2: FILE1是否旧于FILE2 组合测试： 方式一： 123456COMMAND1 &amp;&amp; COMMAND2 并且 COMMAND1 || COMMAND2 或者 ! COMMAND 非 如：[[ -r FILE ]] &amp;&amp; [[ -w FILE ]]注意：&amp;&amp; ||等放在[]外 方式二： 12345EXPRESSION1 -a EXPRESSION2 并且 EXPRESSION1 -o EXPRESSION2 或者 ! EXPRESSION注意：-a..放在[]中 练习：1、编写脚本/bin/per.sh,判断当前用户对指定参数文件，是否不可读并且不可写2、编写脚本/root/bin/excute.sh ，判断参数文件是否为sh后缀的普通文件，如果是，添加所有人可执行权限，否则提示用户非脚本文件3、编写脚本/root/bin/nologin.sh和login.sh,实现禁止和充许普通用户登录系统 read命令——————接受用户输入 常见选项： -p 指定要显示的提示-s 静默输入，一般用于密码-n N 指定输入的字符长度N-d ‘字符’ 输入结束符t N TIMEOUT为N秒 1read -p “Enter a filename: “ FILE 防止扩展： 反斜线（\\）会使随后的字符按原意解释 加引号来防止扩展 单引号（’）防止所有扩展 双引号（”）也防止所有扩展，但是以下情况例外： $（美元符号） － 变量扩展 `（反引号） － 命令替换 \\（反斜线） － 禁止单个字符扩展 !（叹号） － 历史命令替换 bash的配置文件：分类一：按范围 全局配置：/etc/profile/etc/profile.d/*.sh/etc/bashrc 个人配置：~/.bash_profile~/.bashrc 分类二：按功能profile类：为交互式登录的shell提供配置 全局：/etc/profile, /etc/profile.d/*.sh个人：~/.bash_profile功能：(1) 用于定义环境变量(2) 运行命令或脚本 bashrc类：为非交互式和交互式登录的shell提供配置全局：/etc/bashrc个人：~/.bashrc功用：(1) 定义命令别名和函数(2) 定义本地变量 配置文件生效方法一：重新启动shell进程方法二：. 或source 例:. ~/.bashrc bash_logout文件：bash退出任务保存在~/.bash_logout文件中（用户） 在退出登录shell时运行 用于• 创建自动备份• 清除临时文件 补充————$-变量 h：hashall，打开这个选项后，Shell 会将命令所在的路径hash下来，避免每次都要查询。通过set +h将h选项关闭 i：interactive-comments，包含这个选项说明当前的 shell 是一个交互式的shell。所谓的交互shell,在脚本中，i选项是关闭的。 m：monitor，打开监控模式，就可以通过Job control来控制进程的停止、继续，后台或者前台执行等。 B：braceexpand，大括号扩展 H：history，H选项打开，可以展开历史列表中的命令，可以通过!感叹号来完成，例如“!!”返回上最近的一个历史命令，“!n”返回第 n 个历史命令 练习1、让所有用户的PATH环境变量的值多出一个路径，例如：/usr/local/apache/bin 2、用户root登录时，将命令指示符变成红色，并自动启用如下别名：rm=‘rm –i’cdnet=‘cd /etc/sysconfig/network-scripts/’editnet=‘vim /etc/sysconfig/network-scripts/ifcfg-eth0’editnet=‘vim /etc/sysconfig/network-scripts/ifcfg-eno16777736 或 ifcfg-ens33 ’ (如果系统是CentOS7) 3、任意用户登录系统时，显示红色字体的警示提醒信息“Hi,dangerous！” 4、编写生成脚本基本格式的脚本，包括作者，联系方式，版本，时间，描述等 5、编写用户的环境初始化脚本reset.sh，包括别名，登录提示符，vim的设置，环境变量等","categories":[{"name":"shell","slug":"shell","permalink":"http://xinilhy.github.io/categories/shell/"}],"tags":[{"name":"shell编程","slug":"shell编程","permalink":"http://xinilhy.github.io/tags/shell编程/"}]},{"title":"vim基础用法","slug":"vim基础用法","date":"2018-10-02T13:03:54.000Z","updated":"2018-10-15T06:08:22.862Z","comments":true,"path":"2018/10/02/vim基础用法/","link":"","permalink":"http://xinilhy.github.io/2018/10/02/vim基础用法/","excerpt":"vi：Visual Interface，是一种文本编辑器，而vim是vi的增强版，vim是模式化的编辑。 三种模式 命令模式：默认进入vim后所处的模式，支持移动光标，剪切/粘贴文本 插入或编辑模式：修改文本 末行模式：保存退出","text":"vi：Visual Interface，是一种文本编辑器，而vim是vi的增强版，vim是模式化的编辑。 三种模式 命令模式：默认进入vim后所处的模式，支持移动光标，剪切/粘贴文本 插入或编辑模式：修改文本 末行模式：保存退出 模式转换 命令模式——&gt;插入模式：i: insert, 在光标所在处输入I：在当前光标所在行的行首输入a: append, 在光标所在处后面输入A：在当前光标所在行的行尾输入o: 在当前光标所在行的下方打开一个新行O：在当前光标所在行的上方打开一个新行 插入模式——&gt;命令模式： 按ESC 命令模式——&gt;末行模式： 按： 末行模式——&gt;命令模式： 按ESC 插入模式和末行模式不可以直接切换，需要通过命令命令切换 命令模式 光标跳转 12345678910111213141516171819202122字符间跳转：h: 左 l: 右 j: 下 k: 上 # COMMAND：跳转由#指定的个数的字符 单词间跳转：w：下一个单词的词首e：当前或下一单词的词尾b：当前或前一个单词的词首#COMMAND：由#指定一次跳转的单词数当前页跳转：H：页首 M：页中间行 L:页底行首行尾跳转：^: 跳转至行首的第一个非空白字符0: 跳转至行首$: 跳转至行尾行间移动：#G、扩展模式：# ：跳转至由#指定行G：最后一行1G, gg: 第一行 翻屏操作 1234Ctrl+f: 向文件尾部翻一屏Ctrl+b: 向文件首部翻一屏Ctrl+d: 向文件尾部翻半屏Ctrl+u：向文件首部翻半屏 字符编辑 12345x: 删除光标处的字符#x: 删除光标处起始的#个字符xp: 交换光标所在处的字符及其后面字符的位置~:转换大小写J:删除当前行后的换行符 替换命令 12r: 替换光标所在处的字符R:切换成REPLACE模式 删除命令 12345678d$: 删除到行尾d^:删除到非空行首d0:删除到行首dw:删除单词dd：删除光标所在的行#dd: 多行删除D：从当前光标位置一直删除到行尾，留空行，等同于d$ 复制命令 12345678910y$：复制到行尾y0：复制到行首y^：复制到行首yw：复制单词yy：复制当前行#yy：复制多行Y：复制整行 粘贴命令 12p：缓冲区存的如果为整行，则粘贴当前光标所在行的下方；否则，则粘贴至当前光标所在处的后面P：缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，则粘贴至当前光标所在处的前面 改变命令c：修改后切换成插入模式 12345678910c$c^c0cbcecwcc：删除当前行并输入新内容，相当于S#cc: 删除多行并切换为插入模式C：删除当前光标到行尾，并切换成插入模式 撤销更改 123456u撤销最近的更改#u撤销之前多次更改U 撤消光标落在这行后所有此行的更改按Ctrl - r重做最后的“撤消”更改. 重复前一个操作n.重复前一个操作n次 小技巧 1100ixin [ESC] 表示粘贴“xin”100次 12345678用法：&lt;start position&gt;&lt;command&gt;&lt;end position&gt;Command:y 复制、d 删除、gU 变大写、gu 变小写例如 0y$ 命令意味着：0 → 先到行头y → 从这里开始拷贝$ → 拷贝到本行最后一个字符ye 从当前位置拷贝到本单词的最后一个字符 末行模式按“:”进入末行模式 关闭文件 12345:q 退出:q! 强制退出，丢弃做出的修改:w 保存:wq 保存退出:x 保存退出 读取其他文件内容r filename 当前文件另存为w filename 在vim中执行命令！command 暂时退出vim到命令界面: shell , exit返回到vim中 读入命令的输出r! command 地址定界 123456789101112131415161718192021地址定义：（1）:start_pos,end_pos# 具体第#行，例如2表示第2行#,# 从左侧#表示起始行，到右侧#表示结尾行#,+# 从左侧#表示的起始行，加上右侧#表示的行数：2,+3 表示2到5行. 当前行$ 最后一行.,$-1 当前行到倒数第二行% 全文, 相当于1,$（2）/pat1/,/pat2/从第一次被pat1模式匹配到的行开始，一直到第一次被pat2匹配到的行结束#,/pat//pat/,$用法：地址+编辑命令d：删除地址内的内容y：复制内容w file: 将范围内的行另存至指定文件中r file：在指定位置插入指定文件中的所有内容 查找 1234/PATTERN：从当前光标所在处向文件尾部查找?PATTERN：从当前光标所在处向文件首部查找n：与命令同方向N：与命令反方向 查找并替换 123456789s: 在扩展模式下完成查找替换操作格式：s/要查找的内容/替换为的内容/修饰符要查找的内容：可使用模式替换为的内容：不能使用模式，但可以使用\\1, \\2, ...等后向引用符号；还可以使用“&amp;”引用前面查找时查找到的整个内容修饰符：i: 忽略大小写g: 全局替换；默认情况下，每一行只替换第一次出现gc:全局替换，每次替换前询问 查找替换中的分隔符/可替换为其它字符，例如:s@/etc@/var@gs#/boot#/#i","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://xinilhy.github.io/tags/vim/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2018-10-01T01:52:26.000Z","updated":"2018-10-15T06:08:26.175Z","comments":true,"path":"2018/10/01/正则表达式/","link":"","permalink":"http://xinilhy.github.io/2018/10/01/正则表达式/","excerpt":"正则表达式由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能 程序支持：grep,sed,awk,vim, less,nginx,varnish等 分两类： 基本正则表达式：BRE 扩展正则表达式：ERE grep -E, egrep","text":"正则表达式由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能 程序支持：grep,sed,awk,vim, less,nginx,varnish等 分两类： 基本正则表达式：BRE 扩展正则表达式：ERE grep -E, egrep 正则表达式引擎： 采用不同算法，检查处理正则表达式的软件模块 PCRE（Perl Compatible Regular Expressions） 元字符分类：字符匹配、匹配次数、位置锚定、分组 查看帮助：man 7 regex 基本正则表达式字符匹配. 匹配任意单个字符 [] 匹配指定范围内的任意单个字符 [^] 匹配指定范围外的任意单个字符 [:alnum:] 字母和数字 [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:lower:] 小写字母 [:upper:] 大写字母 [:blank:] 空白字符（空格和制表符） [:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广） [:cntrl:] 不可打印的控制字符（退格、删除、警铃...） [:digit:] 十进制数字 [:xdigit:]十六进制数字 [:graph:] 可打印的非空白字符 [:print:] 可打印字符 [:punct:] 标点符号 匹配次数：用在要指定次数的字符后面，用于指定前面的字符要出现的次数12345678 * 匹配前面的字符任意次，包括0次（贪婪模式：尽可能长的匹配） .* 任意长度的任意字符\\? 匹配其前面的字符0或1次\\+ 匹配其前面的字符至少1次\\&#123;n\\&#125; 匹配前面的字符n次\\&#123;m,n\\&#125; 匹配前面的字符至少m次，至多n次\\&#123;,n\\&#125; 匹配前面的字符至多n次\\&#123;n,\\&#125; 匹配前面的字符至少n次 位置锚定：用于定位出现的位置12345678^ 行首锚定，用于模式的最左侧$ 行尾锚定，用于模式的最右侧^PATTERN$ 用于模式匹配整行^$ 空行^[[:space:]]*$ 空白行\\&lt; 或 \\b 词首锚定，用于单词模式的左侧\\&gt; 或 \\b 词尾锚定；用于单词模式的右侧\\&lt;PATTERN\\&gt; 匹配整个单词 分组 分组：() 将一个或多个字符捆绑在一起，当作一个整体进行处理，如：(root)+ 分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \\1, \\2, \\3, … \\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 ，示例： (string1+(string2)*) \\1 ：string1+(string2)* \\2 ：string2 后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身 或者：|示例：a|b: a或b C|cat: C或cat (C|c)at:Cat或cat 示例：1、显示/proc/meminfo文件中以大小s开头的行(要求：使用两种方法)123grep -i &apos;^s&apos; /proc/meminfogrep -i &apos;^[Ss]&apos; /proc/meminfogrep -E &apos;^(S|s)&apos; /proc/meminfo 2、显示/etc/passwd文件中不以/bin/bash结尾的行1grep -v &quot;/bin/bash$&quot; /etc/passwd 3、显示用户rpc默认的shell程序1grep &quot;^rpc\\&gt;&quot; /etc/passwd|cut -d: -f7 4、找出/etc/passwd中的两位或三位数1grep &quot;\\b[0-9]\\&#123;2,3\\&#125;\\b&quot; /etc/passwd 5、显示CentOS7的/etc/grub2.cfg文件中，至少以一个空白字符开头的且后面有非空白字符的行1grep &quot;^[[:space:]]\\+[^[:space:]]&quot; /etc/grub2.cfg 6、找出“netstat -tan”命令结果中以LISTEN后跟任意多个空白字符结尾的行1netstat -tan|grep &quot;\\bLISTEN\\b[[:space:]]\\+$&quot; 7、显示CentOS7上所有系统用户的用户名和UID1grep &quot;/sbin/nologin$&quot; /etc/passwd|cut -d: -f1,3 8、添加用户bash、testbash、basher、sh、nologin(其shell为/sbin/nologin),找出/etc/passwd用户名和shell同名的行12345[root@centos7 ~ ]#grep &quot;^\\([[:alnum:]]\\+\\):.*\\1$&quot; /etc/passwdsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltnologin:x:1006:1006::/home/nologin:/sbin/nologin 9、利用df和grep，取出磁盘各分区利用率，并从大到小排序12345方法1：df|grep &quot;^/dev/sd&quot;|tr -s &quot; &quot; %|cut -d% -f5|sort -nr方法2：df | grep &quot;/dev/sd&quot; | grep -Eo &quot;[0-9]&#123;1,3&#125;%&quot;|grep -Eo &quot;[0-9]&#123;1,3&#125;&quot; 扩展正则表达式egrep = grep -E 语法：egrep [OPTIONS] PATTERN [FILE…]字符匹配：12345678910111213. 任意单个字符 [] 指定范围的字符 [^] 不在指定范围的字符 [:alnum:] 字母和数字[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z[:lower:] 小写字母 [:upper:] 大写字母[:blank:] 空白字符（空格和制表符）[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）[:cntrl:] 不可打印的控制字符（退格、删除、警铃...）[:digit:] 十进制数字 [:xdigit:]十六进制数字[:graph:] 可打印的非空白字符[:print:] 可打印字符[:punct:] 标点符号 次数匹配12345*：匹配前面字符任意次 ?: 0或1次 +：1次或多次 &#123;m&#125;：匹配m次 &#123;m,n&#125;：至少m，至多n次 位置锚定1234^ :行首$ :行尾\\&lt;, \\b :语首\\&gt;, \\b :语尾 分组() 后向引用：\\1, \\2, ... 或者123a|b: a或bC|cat: C或cat(C|c)at:Cat或cat 示例：1、显示三个用户root、mage、wang的UID和默认shell1grep -E &quot;(root|mage|wang)&quot; /etc/passwd 2、找出/etc/rc.d/init.d/functions文件中行首为某单词(包括下划线)后面跟一个小括号的行1grep &quot;^.*\\b[[:space:]]*()&quot; /etc/init.d/functions 3、使用egrep取出/etc/rc.d/init.d/functions中其基名1echo /etc/rc.d/init.d/functions|egrep -o &apos;[^/]+/?$&apos; 4、使用egrep取出上面路径的目录名1echo /etc/rc.d/init.d/functions|egrep -o &apos;^.*/&apos; 5、统计last命令中以root登录的每个主机IP地址登录次数1last|egrep &quot;^root\\b&quot;|tr -s &quot; &quot;|cut -d &quot; &quot; -f1|uniq -c 6、利用扩展正则表达式分别表示0-9、10-99、100-199、200-249、250-25512345grep &quot;\\b[0-9]&quot;grep &quot;\\b[1-9][0-9]&quot;grep &quot;\\b1[0-9][0-9]&quot;grep &quot;\\b2[0-4][0-9]&quot;grep &quot;\\b25[0-5]&quot; 7、显示ifconfig命令结果中所有IPv4地址12345678方法1：ifconfig|grep -o &quot;[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;&quot;方法2：ifconfig|grep -o &quot;\\([0-9]\\&#123;1,3\\&#125;\\.\\)\\&#123;3\\&#125;[0-9]\\&#123;1,3\\&#125;&quot;方法3：ifconfig |grep -Eo &apos;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&apos; 8、将此字符串：welcome to magedu linux 中的每个字符去重并排序，重复次数多的排到前面1echo &quot;welcome to magedu linux&quot; |grep -o &quot;[[:alpha:]]&quot;|sort|uniq -c|sort -nr 9.如何取出eth0网卡的ip地址？123456除了上述三种方法之外，还有下面几种：方法1：ifconfig eth0|grep -w &quot;inet&quot;|grep -o &quot;[0-9.]\\&#123;7,\\&#125;&quot;|head -1方法2：ifconfig eth0|grep -o &quot;inet [0-9.]\\+&quot;|cut -d &quot; &quot; -f2 10.统计/etc/下每个子目录里的.conf结尾的文件的总个数？1ls -R /etc/ |grep &quot;\\.conf$&quot; |wc -l","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://xinilhy.github.io/tags/正则表达式/"}]},{"title":"通配符","slug":"通配符","date":"2018-09-27T02:37:08.000Z","updated":"2018-10-14T14:00:16.396Z","comments":true,"path":"2018/09/27/通配符/","link":"","permalink":"http://xinilhy.github.io/2018/09/27/通配符/","excerpt":"通配符和正则的区别通配符主要匹配文件名，而正则主要匹配文件中的内容； 常用的通配符介绍主要有* 、？、[]这三种；","text":"通配符和正则的区别通配符主要匹配文件名，而正则主要匹配文件中的内容； 常用的通配符介绍主要有* 、？、[]这三种；121. * 匹配零个或多个字符如a*b，与之匹配的可以是aab，ab，a123b，abc..... ？ 匹配任意单个字符如a?b，与之匹配的可以是aab，abb，a1b，a2b…… [] 匹配指定范围内的任意单个字符如[wang] 即匹配w、a、n、g等任意一个字符； [^] 匹配指定范围以外的任意单个字符如[^wang] 排除列表中的所有字符,i与[]相反，即取反； 字符集的表示 注意：对于下面的字符集，如果想要表示其中任意一个字符，需要在外面再加一个[]才可以； 123456789101112[0-9]: 任意数字[a-z]: 注意，这里不仅仅是小写字母，而是a,A ,b,B,c,C...z这样的顺序，即：小写、大写[A-Z]: 注意，这里不仅仅表示大写字母，而是A,b,B,c,C...z,Z的 顺序[:digit:]：任意数字，相当于0-9[:lower:]：任意小写字母 [:upper:]: 任意大写字母[:alpha:]: 任意大小写字母[:alnum:]：任意数字或字母[:blank:]：水平空白字符[:space:]：水平或垂直空白字符，包含空格[:punct:]：标点符号更多内容，可以man 7 glob查看 练习：1. 显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现至少一位数字的文件或目录(1)环境准备：123[root@CentOS6 var ]#touch l2223343434a[root@CentOS6 var ]#touch l22233sddfd34a[root@CentOS6 var ]#touch l22dfdf34a (2)解答：12345[root@CentOS6 var ]#ls /var/l*[[:digit:]]*[[:lower:]]/var/l2223343434a /var/l22233sddfd34a /var/l22dfdf34a或[root@CentOS6 var ]#ls -d /var/l*[0-9]*[[:lower:]]/var/l2223343434a /var/l22233sddfd34a /var/l22dfdf34a 2. 显示/etc目录下以任意一位数字开头，且以非数字结尾的文件或目录(1)准备环境：12345[root@CentOS6 var ]#touch /etc/133rdfdf[root@CentOS6 var ]#touch /etc/123xin[root@CentOS6 var ]#touch /etc/123yuanhonli[root@CentOS6 var ]#touch /etc/abc_xn[root@CentOS6 var ]#touch /etc/1axc_xn (2)解答：12345[root@CentOS6 var ]#ls /etc/[0-9]*[^0-9]/etc/123xin /etc/123yuanhonli /etc/133rdfdf /etc/1axc_xn或[root@CentOS6 var ]#ls /etc/[0-9]*[^[:digit:]]/etc/123xin /etc/123yuanhonli /etc/133rdfdf /etc/1axc_xn 3. 显示/etc/目录下以非字母开头，后面跟了一个字母及其它任意长度任意字符的文件或目录(1准备环境：1234[root@CentOS6 var ]#touch /etc/1axc_xn[root@CentOS6 var ]#touch /etc/_222b[root@CentOS6 var ]#touch /etc/*b22b[root@CentOS6 var ]#touch /etc/xinb22b (2)解答：12[root@CentOS6 var ]#ls /etc/[^[:alpha:]][[:alpha:]]*/etc/1axc_xn /etc/*b22b 4. 显示/etc/目录下所有以rc开头，并后面是0-6之间的数字，其它为任意字符的文件或目录解答：12[root@CentOS6 var ]#ls -d /etc/rc[0-6]* ##注意添加-d选项，否则显示所有目录下的文件/etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d /etc/rc5.d /etc/rc6.d 5. 显示/etc目录下，所有以.d结尾的文件或目录解答：1234567891011[root@CentOS6 var ]#ls -d /etc/*.d/etc/bash_completion.d /etc/logrotate.d /etc/rc0.d /etc/rsyslog.d/etc/chkconfig.d /etc/lsb-release.d /etc/rc1.d /etc/rwtab.d/etc/cron.d /etc/makedev.d /etc/rc2.d /etc/sane.d/etc/depmod.d /etc/modprobe.d /etc/rc3.d /etc/setuptool.d/etc/dnsmasq.d /etc/oddjobd.conf.d /etc/rc4.d /etc/statetab.d/etc/dracut.conf.d /etc/pam.d /etc/rc5.d /etc/sudoers.d/etc/init.d /etc/popt.d /etc/rc6.d /etc/sysctl.d/etc/latrace.d /etc/prelink.conf.d /etc/rc.d /etc/xinetd.d/etc/ld.so.conf.d /etc/profile.d /etc/request-key.d /etc/yum.repos.d[root@CentOS6 var ]# 6. 显示/etc目录下，所有.conf结尾，且以m,n,r,p开头的文件或目录解答：12345[root@CentOS6 var ]#ls -d /etc/[mnrp]*.conf/etc/mke2fs.conf /etc/ntp.conf /etc/prelink.conf /etc/rsyslog.conf/etc/mtools.conf /etc/pbm2ppa.conf /etc/readahead.conf/etc/nfsmount.conf /etc/pm-utils-hd-apm-restore.conf /etc/request-key.conf/etc/nsswitch.conf /etc/pnm2ppa.conf /etc/resolv.conf 7. 只显示/root下的隐藏文件和目录解答：123456789[root@CentOS6 var ]#ls -d /root/.*/root/. /root/.cache /root/.gnote /root/.local /root/.thumbnails/root/.. /root/.config /root/.gnupg /root/.nautilus /root/.viminfo/root/.abrt /root/.cshrc /root/.gtk-bookmarks /root/.pulse /root/.Xauthority/root/.bash_history /root/.dbus /root/.gvfs /root/.pulse-cookie/root/.bash_logout /root/.esd_auth /root/.ICEauthority /root/.ssh/root/.bash_profile /root/.gconf /root/.icons /root/.tcshrc/root/.bashrc /root/.gnome2 /root/.imsettings.log /root/.themes[root@CentOS6 var ]# 8. 只显示/etc下的非隐藏目录解答：12345678[root@CentOS6 var ]#ls -d /etc/[^.]*/etc/123xin /etc/host.conf /etc/prelink.cache/etc/123yuanhonli /etc/hosts /etc/prelink.conf/etc/133rdfdf /etc/hosts.allow /etc/prelink.conf.d/etc/1axc_xn /etc/hosts.deny /etc/printcap/etc/_222b /etc/hp /etc/profile/etc/abc_xn /etc/httpd /etc/profile.d/etc/abrt /etc/idmapd.conf /etc/protocols","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"通配符","slug":"通配符","permalink":"http://xinilhy.github.io/tags/通配符/"}]},{"title":"grep介绍","slug":"grep介绍","date":"2018-09-27T01:59:13.000Z","updated":"2018-10-14T15:17:00.491Z","comments":true,"path":"2018/09/27/grep介绍/","link":"","permalink":"http://xinilhy.github.io/2018/09/27/grep介绍/","excerpt":"这篇文章 ，主要介绍linux三剑客中的老三grep的基本使用 linux文本处理三剑客 grep：文本过滤(模式：pattern)工具 grep, egrep, fgrep（不支持正则表达式搜索） sed：stream editor，文本编辑工具 awk：Linux上的实现gawk，文本报告生成器 grep介绍grep (Global search REgular expression and Print out the line)),是一个文本过滤工具；","text":"这篇文章 ，主要介绍linux三剑客中的老三grep的基本使用 linux文本处理三剑客 grep：文本过滤(模式：pattern)工具 grep, egrep, fgrep（不支持正则表达式搜索） sed：stream editor，文本编辑工具 awk：Linux上的实现gawk，文本报告生成器 grep介绍grep (Global search REgular expression and Print out the line)),是一个文本过滤工具； 1. 作用根据特定的模式，对文件逐行进行匹配检查，打印匹配到的行模式：即过滤的条件，可以由变量、命令、双引号字符等组成； 2. 选项123456789101112131415--color=auto：对匹配到的文本着色显示，Centos7默认已经定义为别名-v: 显示不被模式所匹配到的行，即反选-i: 忽略大小写-n: 显示匹配的行号-c: 统计匹配的行数-o: 仅显示匹配到的字符串，而不是整行，默认显示整行-q: 静默模式，不输出任何信息-e: 实现多个选项之间的逻辑or关系-w: 匹配整个单词-A #(数字): 同after，即把匹配到的行以及后#行显示出来-B #: 同before，即把匹配到的行以及前#行显示出来-C #: 把匹配到的行以及前后各#行都显示出来-E： 相当于egrep，扩展正则表达式，默认grep仅支持标准正则表达式-F: 相当于fgrep，不支持正则表达式-f: 可以匹配两个文件中的公共行 3. 示例如下：1234567891011121314151617## /etc/passwd中包含root的行[root@centos7 test ]#grep &quot;root&quot; /etc/passwdroot:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin注意：这里是过滤包含root字符串的行，而不是以root开头的行；还有就是grep默认是以整行显示。## 使用引号，尤其是带空格的字符[root@centos7 test ]#grep &quot;root:/bin&quot; /etc/passwdroot:x:0:0:root:/root:/bin/bash## 支持变量和命令[root@centos7 test ]#grep $USER /etc/passwdroot:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin[root@centos7 test ]#grep `whoami` /etc/passwdroot:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin -v 1234567891011121314151617181920环境准备[root@CentOS6 data ]#cat test aaabbbcccdddxinxinyuanhohl[root@CentOS6 data ]#grep &apos;a&apos; test aaayuanhohl[root@CentOS6 data ]#grep -v &apos;a&apos; test bbbcccdddxinxin -n 12345[root@CentOS6 var ]#grep -n &quot;UUID&quot; /etc/fstab 9:UUID=91054f47-59f0-4c0f-9136-d1a824233866 / ext4 defaults 1 110:UUID=38fafd9a-a99a-48e2-8112-2016e04db828 /boot ext4 defaults 1 211:UUID=ec1e0b78-b7c4-44b4-90f7-63bd23ed129e /data ext4 defaults 1 212:UUID=a8fd9779-45d3-449b-aa16-12532df94d4b swap swap defaults 0 0 -c 12[root@CentOS6 var ]#grep -c &quot;UUID&quot; /etc/fstab 4 -o 12345[root@CentOS6 var ]#grep -o &quot;UUID&quot; /etc/fstab UUIDUUIDUUIDUUID -q 123[root@CentOS6 var ]#grep -q &quot;UUID&quot; /etc/fstab [root@CentOS6 var ]#echo $?0 -A 、-B、-C 123456789101112131415161718192021222324252627[root@CentOS6 var ]#grep -A 2 &quot;UUID&quot; /etc/fstab UUID=91054f47-59f0-4c0f-9136-d1a824233866 / ext4 defaults 1 1UUID=38fafd9a-a99a-48e2-8112-2016e04db828 /boot ext4 defaults 1 2UUID=ec1e0b78-b7c4-44b4-90f7-63bd23ed129e /data ext4 defaults 1 2UUID=a8fd9779-45d3-449b-aa16-12532df94d4b swap swap defaults 0 0tmpfs /dev/shm tmpfs defaults 0 0devpts /dev/pts devpts gid=5,mode=620 0 0[root@CentOS6 var ]#[root@CentOS6 var ]#grep -B 2 &quot;UUID&quot; /etc/fstab See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#UUID=91054f47-59f0-4c0f-9136-d1a824233866 / ext4 defaults 1 1UUID=38fafd9a-a99a-48e2-8112-2016e04db828 /boot ext4 defaults 1 2UUID=ec1e0b78-b7c4-44b4-90f7-63bd23ed129e /data ext4 defaults 1 2UUID=a8fd9779-45d3-449b-aa16-12532df94d4b swap swap defaults 0 0[root@CentOS6 var ]#grep -C 2 &quot;UUID&quot; /etc/fstab See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#UUID=91054f47-59f0-4c0f-9136-d1a824233866 / ext4 defaults 1 1UUID=38fafd9a-a99a-48e2-8112-2016e04db828 /boot ext4 defaults 1 2UUID=ec1e0b78-b7c4-44b4-90f7-63bd23ed129e /data ext4 defaults 1 2UUID=a8fd9779-45d3-449b-aa16-12532df94d4b swap swap defaults 0 0tmpfs /dev/shm tmpfs defaults 0 0devpts /dev/pts devpts gid=5,mode=620 0 0[root@CentOS6 var ]# -e 123456789101112131415161718192021[root@CentOS6 var ]#grep -e root -e nologin /etc/passwd ##注意每个条件之前都要加-eroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologingopher:x:13:30:gopher:/var/gopher:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinusbmuxd:x:113:113:usbmuxd user:/:/sbin/nologinrpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologinrtkit:x:499:499:RealtimeKit:/proc:/sbin/nologinavahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologinvcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologinabrt:x:173:173::/etc/abrt:/sbin/nologinrpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin -w 12345678910111213环境准备：##默认会将包含root的字符串全部打印；[root@CentOS6 var ]#useradd rooter[root@CentOS6 var ]#grep &quot;root&quot; /etc/passwdroot:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologinrooter:x:501:501::/home/rooter:/bin/bash 使用-w，仅打印root的行[root@CentOS6 var ]#grep -w &quot;root&quot; /etc/passwd root:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin 好了，grep的基本用法就介绍到这里，后期会介绍grep搭配正则表达式，功能更加强大。","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux三剑客","slug":"linux三剑客","permalink":"http://xinilhy.github.io/tags/linux三剑客/"}]},{"title":"文本处理工具","slug":"文本处理工具","date":"2018-09-27T01:52:26.000Z","updated":"2018-10-14T15:10:24.722Z","comments":true,"path":"2018/09/27/文本处理工具/","link":"","permalink":"http://xinilhy.github.io/2018/09/27/文本处理工具/","excerpt":"这篇文章主要介绍一些文本处理工具，包括less、cat、head、tail、cut基础不牢，地动山摇","text":"这篇文章主要介绍一些文本处理工具，包括less、cat、head、tail、cut基础不牢，地动山摇 cat 作用：显示文本内容 选项： -A：显示所有特殊字符，包括空格、windows中的^M -E：显示行结束符$ -n: 对显示出的每一行进行编号 -b：非空行编号 -s：压缩连续的空行成一行 -A 1234567891011## 在windows下新建一个文件，编辑内容如下：aabbcc## 使用rz命令上次到linux[root@centos7 data ]#cat -A test.txt aa^M$ ##显示^M的特殊字符，这表示windows中的回车;$表示行结束符，等同于-E.bb^M$cc[root@centos7 data ]#&gt; 扩展：在windows中的换行符由回车和换行即\\r\\n表示，\\r表示回车，\\n表示换行，而在linux中的换行符仅用\\n表示，于是多出来的\\r被解释成了^M，在linux 编辑文件时发现^M，可以确定在windows中编辑过，特别是在允许脚本的时候，方便排错 cat编辑文件 12345678910111213141516171819[root@centos7 data ]#cat f1abc ## Ctrl+d结束并退出[root@centos7 data ]#cat f1abc[root@centos7 data ]#cat &gt; f2 &lt;&lt;EOF&gt; XIN&gt; YUANHONLI&gt; HAH&gt; EOF ## 末尾和上面的EOF要对应，也可以使用其他的单词表示[root@centos7 data ]#cat f2XINYUANHONLIHAH tac即，cat命令反过来，作用：垂直方向，倒过来显示1234567891011[root@centos7 data ]#cat testaa bbcc dd [root@centos7 data ]#tac testdd cc bbaa rev水平方向，倒过来显示1234[root@centos7 data ]#cat test aabbcc[root@centos7 data ]#rev testccbbaa head作用：显示文本前#行内容 语法：head [OPTION]… [FILE]… 选项： -c #：指定获取前#字节 -n #: 指定获取前#行 -# ：指定行数 123456789101112[root@centos7 data ]#head -c 3 testaab[root@centos7 data ]#[root@centos7 data ]#head -n 3 /etc/fstab ## /etc/fstab## 使用head -c取随机数（要求：大小写字母、数字，10位长度）[root@centos7 data ]#cat /dev/urandom ## urandom是一个设备，存储随机数[root@centos7 data ]#tr -dc &quot;[[:alnum:]]&quot; &lt; /dev/urandom |head -c 10 ##使用tr删除除字母、数字的所有字符，然后head取字符si8eE8JYSI[root@centos7 data ]# tail作用：显示文本后#行内容 语法：tail [OPTION]… [FILE]… 选项： -c #：指定获取后#字节 -n #：指定获取后#行 -# : 指定行数 -f ：跟踪文件描述符，常用于日志监控 -F ：跟踪文件名 tailf类似tail -f -f 和 -F的区别：-F是跟踪文件名，一旦文件被删除，则停止跟踪。而-f即使文件被删除，也还跟踪。 123456789101112131415161718[root@centos7 data ]#cat test aabbcc[root@centos7 data ]#tail -c 2 testc ## 默认会将末尾的换行符也当成一个字节[root@centos7 data ]#cat f1abc[root@centos7 data ]#tail -c 1 f1 [root@centos7 data ]#tail -c 2 f1c ## 同上，末尾的换行符也是一个字节 [root@centos7 data ]#tail -c 3 f1 c cut作用：根据分隔符，取特定的列 语法：cut [OPTION]… [FILE]… 选项： -d delimiter:指定分隔符，默认是tab -f fileds：#：第#列 #,#[,#]:不连续的多个列，例如1,3,6 #-#：连续的多列，例如1-6 混合使用：1-3,7 -c:按字符数取列 –output-delimiter=string:指定输出的分隔符，即自定义分隔符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687在/etc/passwd文件中取出所有用户的UID？[root@centos7 data ]#cut -d: -f3 /etc/passwd0123456781112取出磁盘利用率[root@centos7 data ]#df |tr -s &apos; &apos; |cut -d &quot; &quot; -f5|cut -d% -f1 ##因为空格不只一个，所以使用tr -s压缩为一个空格，然后再取Use700201161100或者直接使用tr压缩时替换分隔符为%，直接取[root@centos7 data ]#df |tr -s &apos; &apos; % |cut -d% -f5Use700201161100自定义分隔符[root@centos7 data ]#cut -d: -f1,3 --output-delimiter=+ /etc/passwdroot+0bin+1daemon+2adm+3[root@centos7 data ]#cut -d: -f1,3 --output-delimiter=== /etc/passwdroot==0bin==1daemon==2adm==3lp==4sync==5shutdown==6按字符数取列[root@centos7 data ]#cut -c1-3 /etc/passwdroobindaeadmlp:synshuhalmai取ip地址: 先取第二行，然后取列CentOS6[root@CentOS6 ~ ]#ifconfig eth0 |grep -w &quot;inet&quot;|tr -s &quot; &quot; :|cut -d: -f4 ##Centos6以：作为分隔符192.168.64.128CentOS7:[root@centos7 data ]#ifconfig ens33 |grep -w &quot;inet&quot; |tr -s &quot; &quot; |cut -d&quot; &quot; -f3192.168.64.134取Centos系统的主版本号：使用与CentOS和CentOS[root@centos7 data ]#cat /etc/centos-releaseCentOS Linux release 7.5.1804 (Core)[root@CentOS6 ~ ]#cat /etc/centos-release CentOS release 6.10 (Final)[root@CentOS6 ~ ]#tr -dc &quot;[:digit:].&quot; &lt; /etc/centos-release |cut -d. -f1 ##除了数字和点不删，其他全部删除6[root@centos7 data ]#tr -dc &quot;[:digit:].&quot; &lt; /etc/centos-release |cut -d. -f17 wcword count的简写，作用：统计一个文件有多少行，多少单词、多少字节、多少字符（注意：字节和字符不一样） 选项： -l 只计数行数 -w 只计数单词总数 -c 只计数字节总数 -m 只计数字符总数 -L 显示文件中最长行的长度12345678910111213141516171819202122232425262728293031323334默认显示行数、单词、字节数[root@centos7 data ]#cat test aabbcc[root@centos7 data ]#wc test1 1 7 test ## 7个字节是因为末尾的换行符的存在由于结果带有文件名，不方便后期做运算，可以用下面的方式仅显示数字[root@centos7 data ]#cat test|wc 1 1 7[root@centos7 data ]#cat /etc/issue\\SKernel \\r on an \\m[root@centos7 data ]#wc -l /etc/issue3 /etc/issue[root@centos7 data ]#cat /etc/issue|wc -l3[root@centos7 data ]#cat /etc/issue|wc -w6[root@centos7 data ]#cat /etc/issue|wc -c23[root@centos7 data ]#cat /etc/issue|wc -m23统计当前登录用户数[root@centos7 data ]#whoroot :0 2018-08-18 10:50 (:0)root pts/0 2018-08-18 10:52 (:0)root pts/1 2018-08-18 10:55 (192.168.64.1)root pts/2 2018-08-18 13:26 (192.168.64.1)root pts/3 2018-08-18 14:30 (192.168.64.1)[root@centos7 data ]#who |wc -l5 sort作用：指定分隔符，根据第几列对文件进行排序 语法：sort [options] file(s) 选项： -t ：指定分隔符，等同于cut的-d选项 -k # ：对第几列进行排序 -n ：按数字大小进行排序，默认按照字母顺序排序 -r ：倒序 -R : 随机排序 -u ：删除输出中的重复行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455取出/etc/passwd文件中的第一列和第三列，并按照数字排序[root@centos7 data ]#cut -d: -f1,3 /etc/passwd |sort -t: -k2 -nroot:0bin:1daemon:2adm:3lp:4sync:5shutdown:6halt:7mail:8operator:11games:12ftp:14rpcuser:29rpc:32ntp:38倒序[root@centos7 data ]#cut -d: -f1,3 /etc/passwd |sort -t: -k2 -nrnfsnobody:65534xin:1000polkitd:999libstoragemgmt:998colord:997saslauth:996setroubleshoot:995chrony:994unbound:993gluster:992geoclue:991gnome-initial-setup:990去重[root@centos7 data ]#cat f1aaaabbbbccdd[root@centos7 data ]#sort -u f1aabbccdd随机抽取学号[root@centos7 data ]#seq 72 |sort -R|head -n114[root@centos7 data ]#seq 72 |sort -R|head -n140[root@centos7 data ]#seq 72 |sort -R|head -n167 uniq作用：删除相邻的重复的行 语法:uniq [OPTION]… [FILE]… 选项： -c: 显示每行重复出现的次数 -d: 仅显示重复过的行 -u: 仅显示不曾重复的行常和sort 命令一起配合使用：sort userlist.txt | uniq -c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101[root@centos7 data ]#cat f1aaaabbaabbbbccdddd[root@centos7 data ]#uniq f1 ## 默认uniq仅删除相邻的重复的行aabbaabbccdd[root@centos7 data ]#sort f1|uniq ##可sort先排序，再uniq删除重复行aabbccdd[root@centos7 data ]#sort f1|uniq -c ## 统计重复出现的次数 3 aa 3 bb 1 cc 2 dd统计一篇英语文档中每个单词出现多少次？并统计出现频率最高的前3个单词？[root@centos7 data ]#cat f1aaaabb yyaa wwwbbbb zzzcc yydd wwdd[root@centos7 data ]#tr -s &quot; &quot; &quot;\\n&quot; &lt; f1 |sort|uniq -c 3 aa 3 bb 1 cc 2 dd 1 ww 1 www 2 yy 1 zzz[root@centos7 data ]#tr -s &quot; &quot; &quot;\\n&quot; &lt; f1 |sort|uniq -c|sort -nr|head -n3 3 bb 3 aa 2 yy[root@centos7 data ]#如何取出两个文件的交集，即相同的行(保证一个文件中没有重复的行)[root@centos7 data ]#cat f1 aabb yyaa wwwbbbb zzzcc yydd wwdd[root@centos7 data ]#cat f2aabb yybbcc yyzzsss[root@centos7 data ]#cat f1 f2|sort |uniq -daabbbb yycc yy或[root@centos7 data ]#grep -f f1 f2aabb yybbcc yy对httpd的access访问日志，判断有多少ip在访问，访问次数分别是多少？取出前10个访问量最多的ip地址？[root@centos7 data ]#cat access_log 192.168.32.7 - - [30/Jul/2018:10:15:34 +0800] &quot;GET / HTTP/1.0&quot; 403 4961 &quot;-&quot; &quot;ApacheBench/2.3&quot;192.168.32.7 - - [30/Jul/2018:10:15:34 +0800] &quot;GET / HTTP/1.0&quot; 403 4961 &quot;-&quot; &quot;ApacheBench/2.3&quot;192.168.32.7 - - [30/Jul/2018:10:15:34 +0800] &quot;GET / HTTP/1.0&quot; 403 4961 &quot;-&quot; &quot;ApacheBench/2.3&quot;192.168.32.7 - - [30/Jul/2018:10:15:34 +0800] &quot;GET / HTTP/1.0&quot; 403 4961 &quot;-&quot; &quot;ApacheBench/2.3&quot;192.168.32.7 - - [30/Jul/2018:10:15:34 +0800] &quot;GET / HTTP/1.0&quot; 403 4961 &quot;-&quot; &quot;ApacheBench/2.3&quot;[root@centos7 data ]#cut -d&quot; &quot; -f1 access_log |sort |uniq -c 2000 192.168.32.17 5 192.168.32.5 1100 192.168.32.7[root@centos7 data ]#cut -d&quot; &quot; -f1 access_log |sort |uniq -c|sort -nr|head 2000 192.168.32.17 1100 192.168.32.7 5 192.168.32.5 diff作用：比较两个文件有什么不同 选项: -u1234567891011121314151617181920212223242526272829303132[root@centos7 data ]#cat f1 aabb yya wwwbbbb zzzcc yydd wwdd[root@centos7 data ]#cat f2aabb yybbcc yyzzsss[root@centos7 data ]#diff -u f1 f2--- f1 2018-08-18 16:45:43.484986457 +0800 ## -开头表示第一个文件+++ f2 2018-08-18 16:31:53.353991142 +0800 ## +开头表示第二个文件@@ -1,8 +1,6 @@ ## 比较的范围：f1的1-8行；f2的1-6行 aa ## 前面为空表示两个文件的交集 bb yy-a www ## 即f1多出a www,删除后两个文件相同 bb-bb zzz cc yy-dd ww-dd+zz ## 即f2多出zz,删除后两个文件相同+sss建议：vimdiff f1 f2 paste作用：横向合并文件 -s：将文件的所有列以一行显示12345678910111213141516171819## 环境准备：[root@centos7 test ]#cat f1aaa bbbcc ddee ff[root@centos7 test ]#cat f2hello worldhostnameifconfig## 合并文件[root@centos7 test ]#paste f1 f2aaa bbb hello worldcc dd hostnameee ff ifconfig## 将f1的内容全部以一行进行显示：[root@centos7 test ]#paste -s f1aaa bbb cc dd ee ff 练习 找出ifconfig “网卡名”结果中本机的ipv4地址？ 1234567CentOS6[root@CentOS6 ~ ]#ifconfig eth0 | grep -w &quot;inet&quot; |tr -s &quot; &quot; :|cut -d: -f4 ##Centos6以：作为分隔符192.168.64.128CentOS7:[root@centos7 data ]#ifconfig ens33 | grep -w &quot;inet&quot; |tr -s &quot; &quot; |cut -d&quot; &quot; -f3192.168.64.134 查出分区空间使用率的最大百分比值？ 12[root@centos7 data ]#df|grep &quot;/dev/sd&quot; |tr -s &quot; &quot; %|cut -d% -f5|sort -nr|head -116 查出用户UID最大值的用户名、UID及shel类型？ 123456[root@centos7 data ]#cut -d: -f1,3,7 /etc/passwd|sort -t: -k2 -nr|head -1nfsnobody:65534:/sbin/nologin或[root@centos7 data ]#sort -t: -k3 -nr /etc/passwd|head -1|cut -d: -f1,3,7nfsnobody:65534:/sbin/nologin 查出/tmp的权限，以数字方式显示1234[root@centos7 data ]#stat /tmp |grep &quot;Access: (&quot; |cut -d&quot;(&quot; -f2 |cut -d&quot;/&quot; -f11777[root@centos7 data ]#stat /tmp |grep &quot;Access: (&quot; |cut -d&quot;(&quot; -f2 |head -c 41777[root@centos7 data ]# 统计当前连接本机的每个远程主机ip的连接数？并按照从大到小排序？1[root@centos7 data ]#netstat -nt |tr -s &quot; &quot; : |cut -d: -f6|sort|uniq -c|sort -nr","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"文本处理工具","slug":"文本处理工具","permalink":"http://xinilhy.github.io/tags/文本处理工具/"}]},{"title":"文件权限","slug":"文件权限","date":"2018-09-26T13:23:05.000Z","updated":"2018-09-27T03:19:55.760Z","comments":true,"path":"2018/09/26/文件权限/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/文件权限/","excerpt":"文件属性","text":"文件属性123&gt; ls -l命令可以查看文件的详细信息[root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 root root 1869 Jul 18 17:44 anaconda-ks.cfg 如图，一个文件的基本属性信息包含8列：文件类型、权限、硬链接数、属主、属组、大小、创建时间、文件名，通过-i选项还可以查看具体的inode值，这里主要介绍权限和归属的修改12[root@centos7 ~ ]#ll -i anaconda-ks.cfg 100663363 -rw-------. 1 root root 1869 Jul 18 17:44 anaconda-ks.cfg 修改文件的属主和属组 chown 修改属主、属组 chgrp 修改属组 chown语法：1chown [OPTION]... [OWNER][:[GROUP]] FILE... 选项：12-R:递归设置，用于目录下的所有文件 chown [OPTION]... --reference=RFILE FILE...：参考文件修改 仅修改属主 12345678910格式：chown owner file示例：[root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 root root 1869 Jul 18 17:44 anaconda-ks.cfg[root@centos7 ~ ]#chown xin anaconda-ks.cfg [root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 xin root 1869 Jul 18 17:44 anaconda-ks.cfg[root@centos7 ~ ]# 同时修改属主和属组 12345678格式：chown owner:group file示例：[root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 xin root 1869 Jul 18 17:44 anaconda-ks.cfg[root@centos7 ~ ]#chown lhy:lhy anaconda-ks.cfg [root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 lhy lhy 1869 Jul 18 17:44 anaconda-ks.cfg 仅修改属组 12345678格式：chown :group file[root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 lhy lhy 1869 Jul 18 17:44 anaconda-ks.cfg[root@centos7 ~ ]#chown :root anaconda-ks.cfg [root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 lhy root 1869 Jul 18 17:44 anaconda-ks.cfg 注意：冒号也可以用点.来代替。 chgrp其实一个chown就可以解决了，但还是的介绍一些chgrp这个命令。语法：1chgrp [OPTION]... GROUP FILE... 选项：同chown12--reference=RFILE ：参考文件设置-R ：递归设置目录下的所有文件的属组 示例：123456[root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 lhy root 1869 Jul 18 17:44 anaconda-ks.cfg[root@centos7 ~ ]#chgrp lhy anaconda-ks.cfg [root@centos7 ~ ]#ll anaconda-ks.cfg -rw-------. 1 lhy lhy 1869 Jul 18 17:44 anaconda-ks.cfg 权限 rwxrwrwx 权限位共9位：左三位：定义user（owner）的权限，属主权限中三位：定义group的权限，属组权限有三位：定义other的权限，其他的权限 r、w、x 123r：readable，可读w：writable，可写x：executble，可执行 对于一个文件或目录来说，r、w、x分别具有不同的功能。 对于文件 123r: 可以查看文件内容w：可以修改文件内容x：为可执行文件，可启动为一个进程 对于目录 123r：可以使用ls查看文件列表w：可以在目录中创建文件，也可以删除文件；x：可以ls 查看文件列表，可以cd进入该目录下 chmod功能：设置文件或者目录的权限语法：12345678chmod [OPTION]... OCTAL-MODE FILE..chmod [OPTION]... MODE[,MODE]... FILE...MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + - 选项：12-R: 递归修改权限--reference=RFILE :参考文件修改 示例：123456789101112&gt; 修改文件的权限为rwx--xr--[root@centos7 data ]#echo &quot;hello world&quot; &gt; f1[root@centos7 data ]#ll f1-rw-r--r-- 2 root root 12 Sep 24 19:52 f1[root@centos7 data ]#chmod u=rwx,g=x f1[root@centos7 data ]#ll f1-rwx--xr-- 2 root root 12 Sep 24 19:52 f1&gt; 也可以通过修改某位的权限实现[root@centos7 data ]#chmod u+x,g=x f1[root@centos7 data ]#ll f1-rwx--xr-- 2 root root 12 Sep 24 19:52 f1 不过这种方法还是有点麻烦，其实还有更加简单的方法，就是用数字表示权限，看图： 其实就是r用数字4表示，w用数字2表示，x用数字1表示； 示例：123456&gt; 修改file权限为rw-r--r--chmod 644 file&gt; 修改file权限为rwxrw-r--chmod 764 file&gt; 修改权限为rwx------chmod 400 file","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"用户和组管理","slug":"用户和组管理","date":"2018-09-26T13:22:56.000Z","updated":"2018-09-27T03:55:09.616Z","comments":true,"path":"2018/09/26/用户和组管理/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/用户和组管理/","excerpt":"用户：在Linux中，用户管理是基于用户和密码的方式进行资源的分配，而UID是用户的唯一标识； 用户 UID 管理员：root 0 登录用户 500+(CentOS6) 1000+(CentOS7) 系统用户 1-499（CentOS6) 1-999)(_CentOS7)","text":"用户：在Linux中，用户管理是基于用户和密码的方式进行资源的分配，而UID是用户的唯一标识； 用户 UID 管理员：root 0 登录用户 500+(CentOS6) 1000+(CentOS7) 系统用户 1-499（CentOS6) 1-999)(_CentOS7) 组同样，GID是组的标识；| 组 | GID || ————- | ——————————— || 管理员组：root | 0 || 非系统组 | 500+(CentOS6) 1000+(CentOS7) || 系统组 | 1-499（CentOS6) 1-999)(CentOS7) | 对组进行分类的话，可以分为主组(私有组)和附加组(公共组)，所谓的主组就是创建用户的时候默认会创建一个与用户名同名的组，这个组内仅包含一个用户，即同名的用户；一个用户可以位于多个组内，而用户除了主组之外所归属的组即用户的附加组。 用户和组的配置文件 /etc/passwd 用户及其属性信息 /etc/shadow 用户密码及其相关属性 /etc/group 组及其属性信息 /etc/gshadow 组密码及其相关属性 passwd文件格式 login name：登录用名（wang） passwd：密码 (x) UID：用户身份编号 (1000) GID：登录默认所在组编号 (1000) GECOS：用户全名或注释 home directory：用户主目录 (/home/wang) shell：用户默认使用shell (/bin/bash) shadow文件格式 登录用名 用户密码:一般用sha512加密 从1970年1月1日起到密码最近一次被更改的时间 密码再过几天可以被变更（0表示随时可被变更） 密码再过几天必须被变更（99999表示永不过期） 密码过期前几天系统提醒用户（默认为一周） 密码过期几天后帐号会被锁定 从1970年1月1日算起，多少天后帐号失效 密码的复杂性策略 使用数字、大写字母、小写字母及特殊字符中至少3种 足够长 使用随机密码 定期更换,不要使用最近曾经使用过的密码 group文件格式 群组名称：就是群组名称 群组密码：通常不需要设定，密码是被记录在 /etc/gshadow GID：就是群组的 ID 以当前组为附加组的用户列表(分隔符为逗号) gshadow文件格式 群组名称：就是群组名称 群组密码： 组管理员列表：组管理员的列表，更改组密码和成员 以当前组为附加组的用户列表：(分隔符为逗号) 用户和组管理命令 用户管理命令 useradd usermod userdel 组管理命令 groupadd roupmod groupdel 用户创建：useradd语法：1useradd [options] LOGIN 选项：123456789101112-u UID-o 配合-u 选项，不检查UID的唯一性-g GID：指明用户所属基本组，可为组名，也可以GID-c &quot;COMMENT&quot;：用户的注释信息-d HOME_DIR: 以指定的路径(不存在)为家目录-s SHELL: 指明用户的默认shell程序可用列表在/etc/shells文件中-G GROUP1[,GROUP2,...]：为用户指明附加组，组须事先存在-N 不创建私用组做主组，使用users组做主组-r: 创建系统用户 CentOS 6: ID&lt;500，CentOS 7: ID&lt;1000-m 创建家目录，用于系统用户-M 不创建家目录，用于非系统用户 默认值设定：/etc/default/useradd文件中 显示或更改默认设置useradd -Duseradd –D -s SHELLuseradd –D –b BASE_DIRuseradd –D –g GROUP 练习： 123456781、创建用户gentoo，附加组为bin和root，默认shell为/bin/csh，注释信息为&quot;Gentoo Distribution&quot;2、创建下面的用户、组和组成员关系名字为webs 的组用户nginx 使用webs 作为附属组用户varnish，也使用webs 作为附属组用户mysql，不可交互登录系统，且不是webs 的成员，nginx，varnish，mysql密码都是magedu 新建用户的相关文件和命令 /etc/default/useradd /etc/skel/* /etc/login.defs newusers passwd格式文件 批量创建用户 chpasswd 批量修改用户口令 用户属性修改：usermod语法：1usermod [OPTION] login 选项：基本同useradd12345678910111213-u UID: 新UID-g GID: 新主组-G GROUP1[,GROUP2,...[,GROUPN]]]：新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项-s SHELL：新的默认SHELL-c &apos;COMMENT&apos;：新的注释信息-d HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据，同时使用-m选项-l login_name: 新的名字；-L: lock指定用户,在/etc/shadow 密码栏的增加 !-U: unlock指定用户,将 /etc/shadow 密码栏的 ! 拿掉-e YYYY-MM-DD: 指明用户账号过期日期-f INACTIVE: 设定非活动期限 删除用户：userdel语法：1userdel [OPTION]... login 选项：1-r: 删除用户家目录 查看用户相关信息123456id [OPTION]... [USER]-u: 显示UID-g: 显示GID-G: 显示用户所属的组的ID-n: 显示名称，需配合ugG使用 切换用户或以其他用户身份执行命令语法：1su [options...] [-] [user [args...]] 切换用户的方式： su UserName：非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录 su - UserName：登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换 root su至其他用户无须密码；非root用户切换时需要密码 换个身份执行命令：su [-] UserName -c ‘COMMAND’ 设置密码语法：1passwd [OPTIONS] UserName: 修改指定用户的密码 选项123456789101112 常用选项：-d:删除指定用户密码-l:锁定指定用户-u:解锁指定用户-e:强制用户下次登录修改密码-f: 强制操作-n mindays: 指定最短使用期限-x maxdays：最大使用期限-w warndays：提前多少天开始警告-i inactivedays：非活动期限--stdin：从标准输入接收用户密码echo &quot;PASSWORD&quot; | passwd --stdin USERNAME 修改用户密码策略语法：1chage [OPTION]... LOGIN 选项：1234567-d LAST_DAY-E --expiredate EXPIRE_DATE-I --inactive INACTIVE-m --mindays MIN_DAYS-M --maxdays MAX_DAYS-W --warndays WARN_DAYS –l 显示密码策略 示例：123chage -d 0 tom 下一次登录强制重设密码chage -m 0 –M 42 –W 14 –I 7 tomchage -E 2016-09-10 tom 用户相关的其它命令 chfn 指定个人信息 chsh 指定shell finger 查看用户信息 创建组：groupadd语法：1groupadd [OPTION]... group_name 选项：1234-g GID: 指明GID号；[GID_MIN, GID_MAX] -r: 创建系统组 CentOS 6: ID&lt;500 CentOS 7: ID&lt;1000 组属性修改：groupmod123groupmod [OPTION]... group-n group_name: 新名字-g GID: 新的GID 组删除：groupdel1groupdel GROUP 更改组密码:gpasswd语法：1gpasswd [OPTION] GROUP 选项：123-a user 将user添加至指定组中-d user 从指定组中移除用户user-A user1,user2,... 设置有管理权限的用户列表 临时切换主组：newgrp1默认创建一个文件的属组是当前用户的主组，可以临时切换主组，从而创建指定归属组的文件，如果切换的组是该用户的附加组，可以直接切换，否则如果用户本不属于此组，则需要组密码 更改和查看组成员语法:1groupmems [options] [action] 选项：1234567options： -g, --group groupname 更改为指定组 (只有root) Actions: -a, --add username 指定用户加入组 -d, --delete username 从组中删除用户 -p, --purge 从组中清除所有成员 -l, --list 显示组成员列表 查看用户所属组列表：groups","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"管道","slug":"管道","date":"2018-09-26T13:22:42.000Z","updated":"2018-09-26T13:32:47.476Z","comments":true,"path":"2018/09/26/管道/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/管道/","excerpt":"管道：用符号”|”表示功能：用来连接命令，即把前一个命令的标准输出作为下一个命令的处理对象 注意：管道只处理标准输出，对于错误输出不进行处理，而显示在终端。","text":"管道：用符号”|”表示功能：用来连接命令，即把前一个命令的标准输出作为下一个命令的处理对象 注意：管道只处理标准输出，对于错误输出不进行处理，而显示在终端。 格式：命令1 | 命令2 | 命令3 | … 示例： 12345678910111213141516171819202122232425## 只有标准输出会转换；[xin@centos7 ~ ]$ls /boot/ /error |tr &apos;a-z&apos; &apos;A-Z&apos;ls: cannot access /error: No such file or directory/BOOT/:CONFIG-3.10.0-862.EL7.X86_64EFIGRUBGRUB2INITRAMFS-0-RESCUE-EABA35925CD4470A8EA2B81643FD49A2.IMGINITRAMFS-3.10.0-862.EL7.X86_64.IMGSYMVERS-3.10.0-862.EL7.X86_64.GZSYSTEM.MAP-3.10.0-862.EL7.X86_64VMLINUZ-0-RESCUE-EABA35925CD4470A8EA2B81643FD49A2## 计算1+2[root@centos7 data ]#echo 1+2|bc3## 计算1+2+3+..100的和方法1：输出1..100的值，然后tr替换空格为+，然后通过管道给bc[root@centos7 data ]#echo &#123;1..100&#125;|tr &apos; &apos; &apos;+&apos;|bc5050方法2：seq命令，-s指定分隔符[root@centos7 data ]#seq -s + 100|bc5050 错误输出默认不能通过管道进行处理，那么有没有什么办法可以处理呢？可以结合2&gt;&amp;1(将错误输出重定向到标准输出，相当于将错误的洗白)实现； 1234567891011[root@centos7 data ]#ls /error |tr &apos;a-z&apos; &quot;A-Z&quot;ls: cannot access /error: No such file or directory## 测试将错误的输出进行洗白[root@centos7 data ]#ls /error 2&gt;&amp;1 |tr &apos;a-z&apos; &quot;A-Z&quot;LS: CANNOT ACCESS /ERROR: NO SUCH FILE OR DIRECTORYok，成功实现；##其实，还有另外一种方法可以实现，只不过是一项新功能，对于一些系统可能无法实现；## 测试使用|&amp;进行洗白[root@centos7 data ]#ls /error |&amp; tr &apos;a-z&apos; &quot;A-Z&quot;LS: CANNOT ACCESS /ERROR: NO SUCH FILE OR DIRECTORY","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"I/O重定向","slug":"I-O重定向","date":"2018-09-26T13:22:35.000Z","updated":"2018-09-27T03:06:45.248Z","comments":true,"path":"2018/09/26/I-O重定向/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/I-O重定向/","excerpt":"标准输入和输出1.计算机中有很多程序，程序的运行依赖于指令，而指令最终服务的是数据；数据无非以下两种： 读入数据：Input 输出数据：Output","text":"标准输入和输出1.计算机中有很多程序，程序的运行依赖于指令，而指令最终服务的是数据；数据无非以下两种： 读入数据：Input 输出数据：Output 2.前面曾经说过：linux一切皆文件； 在linux中，每打开一个文件系统都会自动分配一个fd：file descriptor(文件描述符)，相当于文件的标识编号； 123456789101112131415161718192021## 打开文件，放入后台[root@centos7 ansible ]# /etc/inittab &amp;## 过滤出进程编号[root@centos7 fd ]#ps aux|grep vimroot 4248 0.0 0.3 151112 4948 pts/0 S+ 09:19 0:00 vim /etc/inittabroot 4433 0.0 0.0 112704 972 pts/1 R+ 09:25 0:00 grep --color=auto vim## 进入该进程目录下的fd目录[root@centos7 fd ]#cd /proc/4248/fd[root@centos7 fd ]#ls 0 1 2 4## 查看打开文件的编号；[root@centos7 fd ]#lltotal 0lrwx------ 1 root root 64 Sep 22 09:20 0 -&gt; /dev/pts/0lrwx------ 1 root root 64 Sep 22 09:20 1 -&gt; /dev/pts/0lrwx------ 1 root root 64 Sep 22 09:19 2 -&gt; /dev/pts/0lrwx------ 1 root root 64 Sep 22 09:20 4 -&gt; /etc/.inittab.swp## 4，即打开的文件描述符；剩下的0 、1 、2就是接下来的重点内容。 linux给程序提供三种I/O设备 标准输入（STDIN） -0 默认接受来自键盘的输入 标准输出（STDOUT） -1 默认输出到终端窗口 标准错误（STDERR）-2 默认输出到终端窗口 既然上面都是默认，那么是不是可以不接受键盘的标准输入，不输出到终端，而自定义默认的位置，这就是重定向。 I/O重定向：改变默认位置 输入重定向：原来默认是键盘，可以改成其他的输入，如从文件读取输入； 输出重定向：原来默认是终端，可以改成其他的输出，如输出到文件中； 输出重定向： 正常输出重定向：&gt;（覆盖输出）、&gt;&gt;（追加输出）1234567891011121314准备环境：[root@centos7 data ]#cat f1hello world## 覆盖输出，原文件内容被覆盖；[root@centos7 data ]#echo &quot;passwd &quot; &gt; f1[root@centos7 data ]#cat f1passwd ## 追加输出，保留原文件内容；[root@centos7 data ]#echo &quot;passwd &quot; &gt;&gt; f1[root@centos7 data ]#cat f1passwd passwd 错误输出重定向：2&gt;（覆盖输出）、2&gt;&gt;（追加输出）12345678910111213141516171819## 准备环境：[root@centos7 data ]#cat f2this is hostname is centos6.10## 查看默认错误输出[root@centos7 data ]#ls /filels: cannot access /file: No such file or directory## 覆盖输出，原文件内容被清空；[root@centos7 data ]#ls /file 2&gt; f2[root@centos7 data ]#cat f2ls: cannot access /file: No such file or directory## 追加输出，[root@centos7 data ]#pssh 2&gt;&gt; f2[root@centos7 data ]#cat f2ls: cannot access /file: No such file or directorybash: pssh: command not found...Similar command is: &apos;ssh&apos; 正确和错误的都进行输出重定向：1234567891011121314151617## 标准输出到文件，错误输出到终端[root@centos7 data ]#ls /etc/motd /file &gt; f3ls: cannot access /file: No such file or directory[root@centos7 data ]#cat f3/etc/motd## 标准输出到终端，错误输出到文件[root@centos7 data ]#ls /etc/motd /file 2&gt; f3/etc/motd[root@centos7 data ]#cat f3ls: cannot access /file: No such file or directory## 将标准输出和错误输出都输出到文件[root@centos7 data ]#ls /etc/motd /file &amp;&gt; f3[root@centos7 data ]#cat f3ls: cannot access /file: No such file or directory/etc/motd 输入重定向使用&lt;来重定向标准输入 1234## 使用tr命令读取文件内容，并把小写字符转换成大写[root@centos7 data ]#tr &apos;a-z&apos; &apos;A-Z&apos; &lt; /etc/issue\\SKERNEL \\R ON AN \\M 使用&quot;&lt;&lt;终止词&quot;命令从键盘将多行重导向给标准输入 1234567891011121314151617181920212223242526272829303132## 给xin发邮件，-s指定标题，后面跟接收用户地址[root@centos7 data ]#mail -s &quot;Please call&quot; xin &lt;&lt;EOF&gt; hi wang,&gt; please give me a call when you get in, We may need&gt; EOF## 切换xin，查看邮件[root@centos7 data ]#su - xinLast login: Sat Sep 22 10:16:52 CST 2018 on pts/0## 直接输入mail命令[xin@centos7 ~ ]$mailHeirloom Mail version 12.5 7/5/10. Type ? for help.&quot;/var/spool/mail/xin&quot;: 2 messages 2 new&gt;N 1 root Sat Sep 22 10:19 20/589 &quot;xin&quot; N 2 root Sat Sep 22 10:21 19/648 &quot;Please call&quot;&amp; 2 ## 输入邮件对应编号Message 2:From root@centos7.localdomain Sat Sep 22 10:21:08 2018Return-Path: &lt;root@centos7.localdomain&gt;X-Original-To: xinDelivered-To: xin@centos7.localdomainDate: Sat, 22 Sep 2018 10:21:08 +0800To: xin@centos7.localdomainSubject: Please callUser-Agent: Heirloom mailx 12.5 7/5/10Content-Type: text/plain; charset=us-asciiFrom: root@centos7.localdomain (root)Status: Rhi wang,please give me a call when you get in, We may need&amp; quit ## quit退出 123456## cat结合多行重定向生成文件[xin@centos7 ~ ]$cat &gt;file.txt &lt;&lt;EOF&gt; hello, world&gt; EOF[xin@centos7 ~ ]$cat file.txt hello, world","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"inode和软链接","slug":"inode和软链接","date":"2018-09-26T13:22:08.000Z","updated":"2018-09-27T03:08:25.793Z","comments":true,"path":"2018/09/26/inode和软链接/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/inode和软链接/","excerpt":"inode介绍inode（index node）表：用于存放磁盘上文件的元数据信息。 文件的元数据信息包括如下几个部分：","text":"inode介绍inode（index node）表：用于存放磁盘上文件的元数据信息。 文件的元数据信息包括如下几个部分： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 数据块指针：指向磁盘上文件的真正数据的磁盘块block 有关文件的其他数据 系统通过inode表中的指针寻找文件的数据，而管理员通过文件名引用 cp和inode的关系：cp命令做的事情实际上就是分配一个空闲的inode号，然后在inode表中生成一个新条目，然后在目录中创建一个目录项，然后将名称与inode编号关联，最后拷贝数据生成新的文件 rm和inode的关系：删除文件时，实际上是释放文件的inode号，文件的block数据实际上并不会马上被删除，直到有另一个文件使用该block时才会删除。 mv和inode的关系：mv和inode的关系：如果mv的目标文件和源文件在同一个分区内，那么move后的文件的inode号并不会改变，因为该文件实际的block位置并没有改变。但是如果目标和源在一个不同的分区中， 那么mv就相当于cp和rm了，mv后的文件的inode号将会被改变，因为文件的block变了。 ls -i 显示文件的inode节点号，每个分区的inode节点编号都是独立分配的。因此不同分区中的文件的inode值可能会一样。 df -i 显示每个分区的inode编号最大值，在同一分区mv文件，文件的inode值不变，inode值不变也就意味着磁盘块不变。因此同一分区移动文件特别快 1234567891011121314151617181920212223[root@CentOS6 ~ ]#ll -itotal 1082752725 -rw-------. 1 root root 1445 Sep 19 2018 anaconda-ks.cfg2752533 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Desktop2752537 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Documents2752534 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Downloads2752514 -rw-r--r--. 1 root root 50968 Jul 18 2018 install.log2752515 -rw-r--r--. 1 root root 11698 Jul 18 2018 install.log.syslog2752724 -rw-r--r--. 1 root root 1445 Sep 19 2018 ks6.cfg2752538 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Music2752539 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Pictures2752536 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Public2752535 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Templates2752540 drwxr-xr-x. 2 root root 4096 Sep 14 2018 Videos[root@CentOS6 ~ ]#df -iFilesystem Inodes IUsed IFree IUse% Mounted on/dev/sda2 3203072 104733 3098339 4% /tmpfs 125377 4 125373 1% /dev/shm/dev/sda1 65536 38 65498 1% /boot/dev/sda3 1921360 15 1921345 1% /data/dev/sr0 0 0 0 - /media/CentOS_6.10_Final 硬链接和软链接硬链接 本质上是同一个文件，相当于起一个别名； inode号相同； 创建时硬链接数递增 删除文件： 硬链接数递减 文件要存在，至少有一个链接数； 当硬链接数为0时，该文件被删除； 删除原文件后，依然可以通过硬链接访问； 不能跨越驱动器或分区 不能针对目录创建 语法： 1ln filename [linkname] 符号（软）链接 不同文件，想当于创建一个快捷方式； 一个符号链接的内容是它引用的源文件的内容； inode节点号不同； 创建后硬链接数不增长； 可以对目录创建； 可以跨分区； 删除源文件后，软链接失效； 语法： 1ln -s filename [linkname] readlink命令功能：读取软链接指向的真实路径123456789101112131415161718192021222324252627[root@centos7 / ]#lltotal 32lrwxrwxrwx. 1 root root 7 Jul 18 17:25 bin -&gt; usr/bindr-xr-xr-x. 5 root root 4096 Jul 18 17:44 bootdrwxr-xr-x. 3 root root 22 Sep 21 15:48 datadrwxr-xr-x 19 root root 3300 Sep 21 11:08 devdrwxr-xr-x. 138 root root 12288 Sep 21 14:05 etcdrwxr-xr-x. 3 root root 17 Jul 18 17:43 homelrwxrwxrwx. 1 root root 7 Jul 18 17:25 lib -&gt; usr/liblrwxrwxrwx. 1 root root 9 Jul 18 17:25 lib64 -&gt; usr/lib64drwxr-xr-x. 2 root root 6 Apr 11 12:59 mediadrwxr-xr-x. 2 root root 6 Apr 11 12:59 mntdrwxr-xr-x. 3 root root 16 Jul 18 17:35 optdr-xr-xr-x 223 root root 0 Sep 21 11:07 procdr-xr-x---. 17 root root 4096 Sep 21 15:48 rootdrwxr-xr-x 40 root root 1260 Sep 21 20:01 runlrwxrwxrwx. 1 root root 8 Jul 18 17:25 sbin -&gt; usr/sbindrwxr-xr-x. 2 root root 6 Apr 11 12:59 srvdr-xr-xr-x 13 root root 0 Sep 21 11:07 sysdrwxrwxrwt. 14 root root 4096 Sep 21 16:11 tmpdrwxr-xr-x. 13 root root 155 Jul 18 17:25 usrdrwxr-xr-x. 21 root root 4096 Sep 20 20:42 var[root@centos7 / ]#readlink binusr/bin[root@centos7 / ]#readlink libusr/lib 如何查找一个文件的硬链接文件？1234567891011## 创建硬链接[root@centos7 data ]#ln f1 f4## 查看属性[root@centos7 data ]#ll f1-rw-r--r-- 2 root root 0 Sep 21 20:18 f1## 查找f1的硬链接[root@centos7 data ]#find -samefile f1./f1./f4","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"文件类型和相关命令","slug":"文件类型和相关命令","date":"2018-09-26T13:21:04.000Z","updated":"2018-09-26T13:25:19.352Z","comments":true,"path":"2018/09/26/文件类型和相关命令/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/文件类型和相关命令/","excerpt":"文件类型 -：普通文件 d：目录文件 b：块设备，支持以“block”为单位进行随机访问 c：字符设备，支持以”character”为单位进行线性访问 l：符号链接文件 p：管道文件 s：套接字socket文件","text":"文件类型 -：普通文件 d：目录文件 b：块设备，支持以“block”为单位进行随机访问 c：字符设备，支持以”character”为单位进行线性访问 l：符号链接文件 p：管道文件 s：套接字socket文件 路径绝对路径：从/开始的路径；相对路径名：想对于当前目录的路径； .：当前目录 ..：上级目录 ~：用户的家目录 -：切换上次输入的目录，和命令配合使用 常用命令basename——基名12[root@CentOS6 ~ ]#basename /etc/sysconfig/network-scripts/ifcfg-eth0ifcfg-eth0 dirname——目录名12[root@CentOS6 ~ ]#dirname /etc/sysconfig/network-scripts/ifcfg-eth0/etc/sysconfig/network-scripts pwd——显示当前工作目录12[root@CentOS6 ~ ]#pwd/root cd——切换目录12345678910111213cd：切换到家目录cd ~：切换到家目录cd ~USERNAME：切换到用户USERNAME的家目录cd -：在上一次所在目录与当前目录来回切换（PWD to OLDPWD）cd ..：切换到上级目录cd /path/to/directory 切换到一个绝对目录cd path/to/directory：切换到一个相对目录 ls——列出内容12345678910111213141516-a， --all：列出所有文件包含隐藏文件-A，--almost-all：列出除.和..之外所有的文件-F：-F参数在目录名后加了正斜线（/），以方便用户在输出中分辨它们。类似地，它会在可执行 文件（比如上面的my_script文件）的后面加个星号，以便用户找出可在系统上运行的文件。l，--long：长格式信息，列出文件的详细属性，命令可以简写为ll，alias ll=&apos;ls -l --color=auto&apos;-h，--human-readable：size用人类可读的格式表示-d, --directory：查看目录本身而非内部的文件详情-r, --reverse：反转排序（降序）-R, --recursive 递归显示（基本不用这个，递归显示用tree命令更直观）-t：按修改时间排序 cat命令——查看文件内容选项： -s:压缩空白行为一行 -n：显示行号 -A：显示所有特殊字符 123456[root@CentOS6 test ]#cat -A f1hello world$$my host is xin$$$ tac命令——和cat相反123456[root@CentOS6 test ]#cat f1hello worldmy host is xin[root@CentOS6 test ]#tac f1my host is xinhello world rev命令123[root@CentOS6 test ]#rev f1dlrow ollehnix si tsoh ym stat命令——查看文件状态12345678910[root@CentOS6 test ]#stat f1 File: `f1&apos; Size: 30 Blocks: 8 IO Block: 4096 regular fileDevice: 803h/2051d Inode: 261636 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2008-08-11 21:51:13.173001280 +0800Modify: 2008-08-11 21:51:09.969004686 +0800Change: 2008-08-11 21:51:09.978004008 +0800## 内容有文件权限、文件属主和属组，文件大小，atime、mtime、ctime等内容； touch命令——创建空文件或刷新时间语法： 1touch [OPTION]... FILE... 选项： 12345-a 仅改变 atime和ctime-m 仅改变 mtime和ctime-t [[CC]YY]MMDDhhmm[.ss] 指定atime和mtime的时间戳-c 如果文件不存在，则不予创建，即用于刷新时间； cp命令——复制文件或目录语法： 1234cp [OPTION]... [-T] SOURCE DESTcp [OPTION]... SOURCE... DIRECTORYcp [OPTION]... -t DIRECTORY SOURCE...cp SRC DEST 选项： 1234567891011121314151617-i：覆盖前提示 –n:不覆盖，注意两者顺序-r, -R: 递归复制目录及内部的所有内容-a: 归档，相当于-dR --preserv=all-d：--no-dereference --preserv=links 不复制原文件，只复制链接名--preserv[=ATTR_LIST] mode: 权限 ownership: 属主属组 timestamp: links xattr context all-p: 等同--preserv=mode,ownership,timestamp-v: --verbose-f: --force-u:--update 只复制源比目标更新文件或目标不存在的文件--backup=numbered 目标存在，覆盖前先备份加数字后缀 练习： 1、定义别名命令baketc，每天将/etc/目录下所有文件，备份到/app独立的子目录下，并要求子目录格式为 backupYYYY-mm-dd，备份过程可见 2、创建/app/rootdir目录，并复制/root下所有文件到该目录内，要求保留原有权限 mv——移动和重命名文件语法： 123mv [OPTION]... [-T] SOURCE DESTmv [OPTION]... SOURCE... DIRECTORYmv [OPTION]... -t DIRECTORY SOURCE.. 选项： 12-f：强制移动或覆盖-i：交互式 rm命令——删除语法： 1rm [OPTION]... FILE... 选项： 12345-i 交互式-f 强制删除-r 递归 --no-preserve-root 删除/ 注意：rm -rf /*是可以删除根的，建议对rm命令设置别名，即rm file时移动文件到一个固定目录下。 如何删除大文件？如果删除一个文件后，空间并未成功释放，是由于某个进程在使用该文件。 建议删除文件的步骤： 1234## 先清空文件内容&gt; file## 再rm删除rm -rf file tree命令——以树状形式显示目录结构选项： 12345-d: 只显示目录-L level：指定显示的层级数目-P pattern: 只显示由指定pattern匹配到的路径 mkdir命令——创建目录选项： 123-p：递归创建-v：显示详细信息-m：指定权限 rmdir命令——删除空目录练习：1.如何创建/testdir/dir1/x, /testdir/dir1/y, /testdir/dir1/x/a, /testdir/dir1/x/b, /testdir/dir1/y/a, /testdir/dir1/y/b 2.如何创建/testdir/dir2/x, /testdir/dir2/y, /testdir/dir2/x/a, /testdir/dir2/x/b 3.如何创建/testdir/dir3, /testdir/dir4, /testdir/dir5, /testdir/dir5/dir6, /testdir/dir5/dir7","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"linux简单命令","slug":"linux简单命令","date":"2018-09-26T13:03:54.000Z","updated":"2018-09-27T03:17:32.514Z","comments":true,"path":"2018/09/26/linux简单命令/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/linux简单命令/","excerpt":"linux终端设备终端： 物理终端 虚拟终端","text":"linux终端设备终端： 物理终端 虚拟终端 图形终端 伪终端 什么是shell？Shell 是Linux系统的用户界面，提供了用户与内核进行交互操作的一种接口。 它接收用户输入的命令并把它送入内核去执行 。 shell也是一种高级程序设计语言。 查看系统默认shell？12[root@centos7 data ]#echo $SHELL/bin/bash 查看系统支持的所有shell？123456789[root@centos7 data ]#cat /etc/shells/bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh 命令提示符12[root@centos7 data ]#其中，#为管理员；$为普通用户； 查看提示符格式：12[root@centos7 data ]#echo $PS1\\[\\e[1;42;37m\\][\\u@\\h \\W ]\\$\\[\\e[0m\\] 修改提示符格式：1234567891011PS1=&quot;\\[\\e[1;5;41;33m\\][\\u@\\h \\W]\\\\$\\[\\e[0m\\]&quot; \\e \\033 \\u 当前用户 \\h 主机名简称 \\H 主机名 \\w 当前工作目录 \\W 当前工作目录基名 \\t 24小时时间格式 \\T 12小时时间格式 \\! 命令历史数 \\# 开机后命令历史数 颜色配置：字体颜色和背景颜色格式： 12345678910111213\\e[F;Bm \\e[0m ## \\e等同于\\033,尾部以&apos;\\e[0m&apos;关闭颜色输出##F是背景颜色，B是字体颜色F B30 40 黑色31 41 红色32 42 绿色33 43 黄色 34 44 蓝色35 45 紫红色36 46 青蓝色37 47 白色另外：1表示高亮显示；5表示闪烁 示例： 查看帮助：man bash——————/PROMPTING linux命令介绍分类内部命令shell集成的，当用户登录时，根据/etc/passwd进行加载shell，并把命令加载到内存中。 查看: 12helpenable 外部命令在文件系统路径下有对应的可执行程序文件 查看： 1which -a |--skip-alias ; whereis 判断内部或外部命令1type -a command ### hash缓存表系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命 令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解 释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找。 利用hash缓存表可大大提高命令的调用速率 hash常见用法12345678## 显示hash缓存hash -l## 清除name缓存hash -d name## 清除所有缓存hash -r 命令别名显示当前shell进程所有可用的命令别名1alias 定义别名1alias NAME=&apos;VALUE&apos; 注意：在命令行中定义的别名，仅对当前shell进程有效 永久保存：1234567只有写入配置文件才能永久保存仅对当前用户：~/.bashrc 对所有用户有效：/etc/bashrc默认写入文件后，不会立即生效，需要bash进程重新读取配置文件source /path/to/config_file. /path/to/config_file 撤销别名12unalias [-a] name-a:取消所有别名 如何执行原命令123456\\command&quot;command&quot;&apos;command&apos;##如果是外部命令，还可以使用绝对路径执行/path/command 命令格式1COMMAND [OPTIONS...] [ARGUMENTS...] 选项：实现特定的功能 ​ 短选项：-c，例如：-h，-l ​ 长选项：–word 例如：–all, –human-readable 参数：命令的作用对象，比如文件名，用户名等 注意： 多个选项以及多参数和命令之间使用空白字符分隔 取消和结束命令执行：Ctrl+c，Ctrl+d 多个命令可以用;符号分开 一个命令可以用\\分成多行 日期和时间linux的两种时钟​ 系统时钟：由Linux内核通过CPU的工作频率进行的 ​ 硬件时钟：主板 命令： ​ 查看或设置系统时间：date 123456789101112131415161718192021222324252627## 显示CST时间[root@centos7 data ]#dateFri Sep 21 16:45:17 CST 2018## 显示utc时间[root@CentOS6 ~ ]#date --utcFri Sep 21 08:26:24 UTC 2018## 以年、月、date +%F：date +%Y-%m-%d或者date +%F## 以时、分、秒格式显示：date +%H:%M:%S或 date +%T## 计算当前时间到1970-1-1（unix的诞生日）的秒date +%s## 转换为天数date -d @+上面的秒## 显示昨天的时间date -d &apos;-1 day&apos;## 显示明天的时间date -d &apos;1 day&apos;&gt; date -d支持：day、month、year 12设置时间date -s &quot;2008-08-11 20:00:00&quot; ​ 查看硬件时间：clock或hwclock 123456[root@CentOS6 ~ ]#clockFri 21 Sep 2018 05:28:57 PM CST -0.125678 seconds选项：-s, --hctosys 设置系统时间，硬件时间覆盖系统时间。-w, --systohc 设置硬件时间，系统时间覆盖硬件时间。 关机和重启命令关机：halt poweroff重启：reboot​ -f：强制，不调用shutdown ​ -p：切断电源 关机或重启：shutdown ​ shutdown [OPTION]… TIME [MESSAGE] ​ -r: reboot ​ -h: halt ​ -c：cancel ​ TIME:无指定，默认相当于 +1 ​ now: 立刻,相当于+0 ​ +m: 相对时间表示法，几分钟之后；例如 +3 ​ hh:mm: 绝对时间表示，指明具体时间 screen命令1234567891011121314151617创建新screen会话 screen –S [SESSION] 加入screen会话 screen –x [SESSION] 退出并关闭screen会话exit 剥离当前screen会话Ctrl+a,d 显示所有已经打开的screen会话 screen -ls 恢复某screen会话 screen -r [SESSION] echo命令功能：显示字符语法：echo [-neE][字符串]说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开,并在最后加上换行号 选项：12345678910111213141516171819202122232425262728293031323334353637-E （默认）不支持 \\ 解释功能-n 不自动换行 -e 启用 \\ 字符的解释功能显示变量:echo $变量名启用命令选项-e，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出​ \\a alert (bell)————发出警告声​ \\b backspace————删除前一个字符​ \\c suppress further output——————最后不加上换行符号​ \\e escape character————————\\033​ \\f form feed————————————换行但光标仍旧停留在原来的位置；​ \\n new line————————————换行且光标移至行首；​ \\r carriage return——————————光标移至行首，但不换行，即覆盖开始内容​ \\t horizontal tab——————————插入tab​ \\v vertical tab—————————— \\v 与\\f相同​ \\\\ backslash————————————插入一个“\\”​ \\0nnn ，插入nnn（八进制）所代表的ASCII字符 echo -e &apos;\\033[43;31;5mmagedu\\033[0m&apos;​ \\xHH 插入HH（十六进制）所代表的ASCII字符 命令行扩展 $( ) 或 1234567## 调用主机名[root@CentOS6 ~ ]#echo &quot;This system&apos;s name is $(hostname)&quot; This system&apos;s name is CentOS6.10## 调用当前用户[root@CentOS6 ~ ]#echo &quot;i am `whoami` &quot;i am root 括号扩展：{}功能:打印重复 字符串的简化形式 1234567891011121314151617181920212223## 打印连续的数字[root@CentOS6 ~ ]#echo &#123;1..10&#125;1 2 3 4 5 6 7 8 9 10## 打印不连续的数字[root@CentOS6 ~ ]#echo &#123;1,3,5&#125;1 3 5## 打印字母[root@CentOS6 ~ ]#echo &#123;a..z&#125;a b c d e f g h i j k l m n o p q r s t u v w x y z## 结合步进，打印奇数[root@CentOS6 ~ ]#echo &#123;1..10..2&#125;1 3 5 7 9## 可以用来创建固定前缀的文件，减少重复操作[root@CentOS6 ~ ]#echo file&#123;1,3,5&#125;file1 file3 file5## 删除[root@CentOS6 ~ ]#rm -f file&#123;1,3,5&#125; 命令行历史1234567执行前一条命令（去除参数）： !:0执行history命令输出对应序号n的命令： !n执行history历史中倒数第n个命令: !-ncommand !^ 利用上一个命令的第一个参数做cmd的参数command !$ 利用上一个命令的最后一个参数做cmd的参数command !* 利用上一个命令的全部参数做cmd的参数command !:n 利用上一个命令的第n个参数做cmd的参数 history命令语法: 123history [-c] [-d offset] [n]history -anrw [filename]history -ps arg [arg...] 选项： 12345678910-c: 清空命令历史-d offset: 删除历史中指定的第offset个命令 n: 显示最近的n条历史，默认列出所有历史记录-a: 追加本次会话新执行的命令历史列表至历史文件-r: 读历史文件附加到历史列表-w: 保存历史列表到指定的历史文件-n: 读历史文件中未读过的行到历史列表-p: 展开历史参数成多行，但不存在历史列表中-s: 展开历史参数成一行，附加在历史列表后 bash快捷键123456789Ctrl + l 清屏，相当于clear命令Ctrl + c 终止命令Ctrl + z 挂起命令Ctrl + c 终止命令Ctrl + z 挂起命令Ctrl + u 从光标处删除至命令行首Ctrl + k 从光标处删除至命令行尾Alt + r 删除当前整行Alt + N 提示输入指定字符后，重复显示该字符N次 whatis命令功能：显示命令的简短描述 基于数据库进行查询 刚安装后不可立即使用，需要makewhatis(Centos6) mandb(Centos7)制作数据库 示例： 1whatis cal 或 man –f cal 如何获取命令帮助？内部命令123help commandman bash 外部命令​ 123456789101112方法1：command --help方法2：使用man手册方法3：info command方法4：程序自身的帮助文档 README INSTALL ChangeLog方法5：发行版的官方文档方法6：程序官方文档建议：先whatis command查看具体的章节，然后再man 章节 command获取帮助。","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"linux基础知识","slug":"linux基础知识","date":"2018-09-26T12:59:20.000Z","updated":"2018-09-26T13:19:23.536Z","comments":true,"path":"2018/09/26/linux基础知识/","link":"","permalink":"http://xinilhy.github.io/2018/09/26/linux基础知识/","excerpt":"计算机系统的组成计算机系统由硬件(Hardware)系统和软件(Software)系统两大部分组成","text":"计算机系统的组成计算机系统由硬件(Hardware)系统和软件(Software)系统两大部分组成 冯·诺依曼体系结构： 1946年数学家冯·诺依曼于提出 运算器、控制器、存储器、输入设备、输出设备 linux起源1991年的10月5日，Torvalds在comp.os.minix新闻组上发布 消息，正式向外宣布他自行编写的完全自由免费的内核诞生 （Freeminix-like kernel sources for 386-AT）——— FREAX，英文含义是怪诞的、怪物、异想天开 类Unix的内核，在GPL下发布 官网：www.kernel.org 如：CentOS,Ubuntu,Android linux发行版 slackware:SUSE linux Enterprise Server debian: Ubuntu , mint redhat： RHEL: RedHat Enterprise Linux ArchLinux：轻量简洁 Gentoo：极致性能，不提供传统意义的安装程序 LFS: Linux From scratch 自制Linux Android: kernel+busybox（工具集）+java虚拟机 linux分支参考网站 ​ http://futurist.se/gldt/ ​ http://www.mindpin.com/d3js-demo/linux/ linux内核 linux哲学思想 一切都是一个文件（包括硬件） 小型，单一用途的程序 链接程序，共同完成复杂的任务 避免令人困惑的用户界面 配置数据存储在文本中 获取linux发行版 https://wiki.centos.org/Download http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com","categories":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://xinilhy.github.io/tags/linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-12T05:15:18.789Z","updated":"2018-09-26T13:38:55.288Z","comments":true,"path":"2018/09/12/hello-world/","link":"","permalink":"http://xinilhy.github.io/2018/09/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}